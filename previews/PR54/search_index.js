var documenterSearchIndex = {"docs":
[{"location":"role/#Roles","page":"Roles","title":"Roles","text":"","category":"section"},{"location":"role/","page":"Roles","title":"Roles","text":"Roles are used to provide a mechanism for reusability and modularization of functionsalities provided/implemented by agents. Every agent can contain and unlimited number of roles, which are separate structs on which typical agent functionalitites (like send_message) can be defined. All roles of an agent share the same address and agent id, as they are part of the agent and no autonomous unit for themself. ","category":"page"},{"location":"role/#Role-definition","page":"Roles","title":"Role definition","text":"","category":"section"},{"location":"role/","page":"Roles","title":"Roles","text":"A role can be defined using the @role macro. This macro adds some baselinefields to the following struct definition. The struct can be defined like any other Julia struct.","category":"page"},{"location":"role/","page":"Roles","title":"Roles","text":"# Define your role struct using @role macro\n@role struct MyRole\n    my_own_field::String\nend\n\n# Assume you have already defined roles using Mango.AgentRole module\nrole1 = MyRole(\"Role1\")","category":"page"},{"location":"role/","page":"Roles","title":"Roles","text":"Most functions, used for agent development can also be used with roles (e.g. handle_message, address, schedule, send_message (plus variants) and the lifecycle methods).  ","category":"page"},{"location":"role/","page":"Roles","title":"Roles","text":"Additionally, roles can define the setup function to define actions to take when the roles are added to the agent. It is also possible to subscribe to specific messages using a boolean expression with the subscribe_message(role::Role, handler::Function, condition::Function) function. With the @role macro, the role context is added to the role, which contains the reference to the agent. However, it is recommended to use the equivalent methods defined on the role to execute actions like scheduling and sending messages. Further with roles it is possible to listen to all messages sent from within the agent. For this subscribe_send(role, handler::Function) can be used.","category":"page"},{"location":"role/#Role-communication","page":"Roles","title":"Role communication","text":"","category":"section"},{"location":"role/","page":"Roles","title":"Roles","text":"Besides the message subscriptions there are functionalities to communicate/work together with other roles. There are two different mechanisms for this:","category":"page"},{"location":"role/","page":"Roles","title":"Roles","text":"Data sharing\nAn event system","category":"page"},{"location":"role/#Data-sharing","page":"Roles","title":"Data sharing","text":"","category":"section"},{"location":"role/","page":"Roles","title":"Roles","text":"The data sharing can be used using ordinary Julia structs with default constructors. There are two ways to share the data, first you can create the model you want share with get_model(role, your_data_model_type)","category":"page"},{"location":"role/","page":"Roles","title":"Roles","text":"struct TestModel\n    c::Int64\nend\nTestModel() = TestModel(42)\nrole = MyRole(\"Role1\")\nshared_model = get_model(role, TestModel)","category":"page"},{"location":"role/","page":"Roles","title":"Roles","text":"Mango.jl will create a TestModel instance and manage this instance such that every role can access it. ","category":"page"},{"location":"role/","page":"Roles","title":"Roles","text":"Although this is a straightforward method it can be very clumsy to use. For this reason there is the macro @shared, which can be used within a role definition to mark a field as shared model. Then, Mango.jl will ensure that a shared instance of the declared type will be created and assigned to the struct field.","category":"page"},{"location":"role/","page":"Roles","title":"Roles","text":"@role struct SharedFieldTestRole\n    @shared \n    test_model::TestModel\nend","category":"page"},{"location":"role/#Event-system","page":"Roles","title":"Event system","text":"","category":"section"},{"location":"role/","page":"Roles","title":"Roles","text":"Roles can emit events using emit_event(role, event::Any, event_type::Any=nothing). If event_type is nothing, the type of event will be used as event_type. To handle these events roles can subscribe using subscribe_event(role, event_type::Any, event_handler::Function, condition::Function) or add a method to handle_event. The condition function shall have the signature (source_role::Role, event::Any)::Boolean. The event handler shall have the signature (role::Role, source::Role, event::Any, event_type::Any).","category":"page"},{"location":"role/","page":"Roles","title":"Roles","text":"\nstruct TestEvent\nend\n\nfunction handle_event(role::Role, src::Role, event::TestEvent; event_type::Any)\n    @info \"Event is arriving!\"\nend\nfunction custom_handler(role::Role, src::Role, event::Any, event_type::Any)\n    @info \"Event is also arriving!\"\nend\n\n@agent struct RoleTestAgent\n    counter::Integer\nend\n\nagent = RoleTestAgent(0)\n\nrole_emitter = MyRole(\"Role1\")\nrole_handler = MyRole(\"Role1\")\n\nadd(agent, role_emitter)\nadd(agent, role_handler)    \nsubscribe_event(role1, TestEvent, custom_handler, (src, event) -> true) # condition is optional\n\nemit_event(role_emitter, TestEvent())","category":"page"},{"location":"simulation/#Simulation-Container","page":"Simulation","title":"Simulation Container","text":"","category":"section"},{"location":"simulation/","page":"Simulation","title":"Simulation","text":"The simulation container has the same role as the real-time container and therefore acts as communication and interaction interface to the environment. The simulation container maintains an interal simulation time and only executes tasks and delivers messages according to the requested step_sizes. It can be stepped in the continous mode or the discrete event mode. Further the container manages a common environment the agents can interact with as base structure for agent-based modeling simulations.","category":"page"},{"location":"simulation/#Create-and-stepping-a-simulation-container","page":"Simulation","title":"Create and stepping a simulation container","text":"","category":"section"},{"location":"simulation/","page":"Simulation","title":"Simulation","text":"To create a simulation container, it is advised to use create_simulation_container. This method will create a clock with the given simulation time and set default for the communication simulation and the general task simulation. In most cases the default task simulation will be what you desire. The communication simulation object (based on the abstract type CommunicationSimulation) is used to determine the delays of the messages in the simulation, while the task simulation determines the way the tasks are scheduled (within a time step, using parallelization etc.) in the simulation. ","category":"page"},{"location":"simulation/","page":"Simulation","title":"Simulation","text":"In the following example a simple simulation is executed.","category":"page"},{"location":"simulation/","page":"Simulation","title":"Simulation","text":"# Arbitrary agent definition\n@agent struct SimAgent\nend\n\n# Create a communication simulator, the simple communication simulator works with static delays between specific agents and a global default, here 0\ncomm_sim = SimpleCommunicationSimulation(default_delay_s=0)\n# Set the simulation time to an initial value\ncontainer = create_simulation_container(DateTime(Millisecond(1000)), communication_sim=comm_sim)\n\n# Creating agents and registering, no difference here to the real time container\nagent1 = SimAgent(0)\nagent2 = SimAgent(0)\nregister(container, agent1)\nregister(container, agent2)\n\n# Send a message from agent2 to agent1, the message will be written to a queue instead of processed by some protocol\nsend_message(agent2, \"Hello Friends, this is RSc!\", AgentAddress(aid=agent1.aid))\n\n# in this stepping call the message will be delivered and handled to/by the agent1  \n# step_size=1, if no size is specified the simulation will work as discrete event simulation, executing all tasks occurring on the next event time.\nstepping_result = step_simulation(container, 1)","category":"page"},{"location":"simulation/#Discrete-event-vs-continous-stepping","page":"Simulation","title":"Discrete event vs continous stepping","text":"","category":"section"},{"location":"simulation/","page":"Simulation","title":"Simulation","text":"Mango.jl support discrete event and continous stepping. Discrete event stepping means that no advance time is provided instead the simulation jumps to the next event time and executes every tasks, delivers every message scheduled at this next event time. For example, you set up a simultion in which three tasks are in the queue at the event times 1,1,3; then the next step would execute the first two, and the following would execute the last task (given no new tasks are created). With continous stepping the user has to provide a stepsize (in seconds), which will be used to execute every task until `simulationtime + step_size` ordered by the time of the individual tasks. It is also possible to mix both styles.","category":"page"},{"location":"simulation/","page":"Simulation","title":"Simulation","text":"# continous\nstepping_result = step_simulation(container, 1)\n# discrete event\nstepping_result = step_simulation(container)","category":"page"},{"location":"simulation/#Communication-simulation","page":"Simulation","title":"Communication simulation","text":"","category":"section"},{"location":"simulation/","page":"Simulation","title":"Simulation","text":"Mango.jl is generally designed to be extenable, this is also true for the usage of a communication simulator in a Mango.jl-Simulation. To use a custom communication simulator, you can simply set the keyword argument communication_sim to a struct of the abstract type CommunicationSimulation. To implement this type, you need to add a fitting method to Mango.calculate_communication::CommunicationSimulation, clock::Clock, messages::Vector{MessagePackage})::CommunicationSimulationResult. This method will then be called in the simulation loop at least once and repeatedly when new messages arrive and therefore a new state has to be determined.","category":"page"},{"location":"simulation/","page":"Simulation","title":"Simulation","text":"The default communication simulator is SimpleCommunicationSimulation. This simulator uses a default static delay together with a dictionary containing delays per link between individual agents.","category":"page"},{"location":"simulation/#Agent-based-modeling","page":"Simulation","title":"Agent-based modeling","text":"","category":"section"},{"location":"simulation/","page":"Simulation","title":"Simulation","text":"The simulation container can also be used for simple agent-based modeling simulations. In agent-based modeling, units (e.g. people, cars, ...) are modeled using agents and their interaction between these agents and further units in a common world/environment. To support this the simulation container provides on_step(agent::Agent, world::World, clock::Clock, step_size_s::Real) (also defined on Role). ","category":"page"},{"location":"simulation/","page":"Simulation","title":"Simulation","text":"The World can contain common objects to interact with and contains a Space struct which can define the type of world modeled (2D/3D/Graph/...). This struct also contains the positions of all agents. Currently there is only the Space2D implementation with simple cartesian coordinates. ","category":"page"},{"location":"simulation/","page":"Simulation","title":"Simulation","text":"Please note that Mango.jl focuses on agent-based control, agent-based communication and therefore currently does not provide much supporting implementations for complex agent-based modeling simulations.","category":"page"},{"location":"scheduling/#Scheduling","page":"Scheduling","title":"Scheduling","text":"","category":"section"},{"location":"scheduling/#.-Introduction","page":"Scheduling","title":"1. Introduction","text":"","category":"section"},{"location":"scheduling/","page":"Scheduling","title":"Scheduling","text":"Welcome to the documentation for the Scheduling component in Mango.jl. This utility component provides a flexible scheduler for executing predefined tasks. It offers various TaskData types to specify different task execution behaviors.","category":"page"},{"location":"scheduling/#.-Module-Overview","page":"Scheduling","title":"2. Module Overview","text":"","category":"section"},{"location":"scheduling/","page":"Scheduling","title":"Scheduling","text":"The Scheduling module exports several types and functions to facilitate task scheduling and execution. Let's briefly review the main components of this module.","category":"page"},{"location":"scheduling/#Task-Data-Types","page":"Scheduling","title":"Task Data Types","text":"","category":"section"},{"location":"scheduling/","page":"Scheduling","title":"Scheduling","text":"The module provides different TaskData types, each catering to specific scheduling requirements:","category":"page"},{"location":"scheduling/","page":"Scheduling","title":"Scheduling","text":"PeriodicTaskData: For tasks that need to be executed periodically, it holds the time interval in seconds between task executions.\nInstantTaskData: For tasks that need to be executed instantly, without any delay.\nDateTimeTaskData: For tasks that need to be executed at a specific date and time.\nAwaitableTaskData: For tasks that require waiting for an awaitable object to complete before execution.\nConditionalTaskData: For tasks that execute based on a specific condition at regular intervals.","category":"page"},{"location":"scheduling/#Typical-usage","page":"Scheduling","title":"Typical usage","text":"","category":"section"},{"location":"scheduling/","page":"Scheduling","title":"Scheduling","text":"Typically the scheduler is used within methods from the agent. To schedule a task the function schedule can be used. It takes two inputs: The agent (which forwards the call to its scheduler) and the TaskData object of the task.","category":"page"},{"location":"scheduling/","page":"Scheduling","title":"Scheduling","text":"agent = MyAgent(0)\nresult = 0\n\nschedule(agent, InstantTaskData()) do \n    # some expensive calculation\n    result = 10       \nend\nwait_for_all_tasks(agent)","category":"page"},{"location":"scheduling/","page":"Scheduling","title":"Scheduling","text":"PeriodicTaskData creates tasks that get executed repeatedly forever.  This means that calling wait on such a task will generally simply block forever. For this reason a periodic task has to be stopped before it can be waited on.","category":"page"},{"location":"scheduling/","page":"Scheduling","title":"Scheduling","text":"delay_in_s = 0.5 # delay between executions of the task in seconds\n\nt = schedule(agent, PeriodicTaskData(delay)) do \n    # some expensive calculation\n    result = 10       \nend\n\nstop_task(agent, t)\nwait_for_all_tasks(agent)","category":"page"},{"location":"scheduling/","page":"Scheduling","title":"Scheduling","text":"Alternatively, you can stop all stopable tasks simultaneously with the stop_all_tasks function.","category":"page"},{"location":"scheduling/","page":"Scheduling","title":"Scheduling","text":"delay_in_s = 0.5 # delay between executions of the task in seconds\n\nfor i in 1:100\n    schedule(agent, PeriodicTaskData(delay)) do \n        # some expensive calculation\n        result = 10       \n    end\nend\n\nstop_all_task(agent, t)\nwait_for_all_tasks(agent)","category":"page"},{"location":"scheduling/","page":"Scheduling","title":"Scheduling","text":"Finally, stop_and_wait_for_all_tasks is a convenience methods combining both stop_all_tasks and wait_for_all_tasks.","category":"page"},{"location":"scheduling/#.-Scheduler","page":"Scheduling","title":"3. Scheduler","text":"","category":"section"},{"location":"scheduling/","page":"Scheduling","title":"Scheduling","text":"The Scheduler type is an internal structure that holds a collection of tasks to be scheduled and executed. Every agent contains such a scheduler struct by default and implements methods for convenient delegation.","category":"page"},{"location":"scheduling/#Structure","page":"Scheduling","title":"Structure","text":"","category":"section"},{"location":"scheduling/","page":"Scheduling","title":"Scheduling","text":"struct Scheduler\n    tasks::Vector{Task}\nend","category":"page"},{"location":"scheduling/#.-Functions","page":"Scheduling","title":"4. Functions","text":"","category":"section"},{"location":"scheduling/#execute_task","page":"Scheduling","title":"execute_task","text":"","category":"section"},{"location":"scheduling/","page":"Scheduling","title":"Scheduling","text":"The execute_task function executes a task with a specific TaskData.","category":"page"},{"location":"scheduling/#Signatures","page":"Scheduling","title":"Signatures","text":"","category":"section"},{"location":"scheduling/","page":"Scheduling","title":"Scheduling","text":"execute_task(f::Function, data::PeriodicTaskData)\nexecute_task(f::Function, data::InstantTaskData)\nexecute_task(f::Function, data::DateTimeTaskData)\nexecute_task(f::Function, data::AwaitableTaskData)\nexecute_task(f::Function, data::ConditionalTaskData)","category":"page"},{"location":"scheduling/#schedule","page":"Scheduling","title":"schedule","text":"","category":"section"},{"location":"scheduling/","page":"Scheduling","title":"Scheduling","text":"The schedule function adds a task to the scheduler with the specified TaskData and scheduling type.","category":"page"},{"location":"scheduling/#Signature","page":"Scheduling","title":"Signature","text":"","category":"section"},{"location":"scheduling/","page":"Scheduling","title":"Scheduling","text":"schedule(f::Function, scheduler::Union{Scheduler,Agent}, data::TaskData, scheduling_type::SchedulingType=ASYNC)","category":"page"},{"location":"scheduling/#wait*for*all_tasks","page":"Scheduling","title":"waitforall_tasks","text":"","category":"section"},{"location":"scheduling/","page":"Scheduling","title":"Scheduling","text":"The wait_for_all_tasks function waits for all the scheduled tasks in the provided scheduler to complete.","category":"page"},{"location":"scheduling/#Signature-2","page":"Scheduling","title":"Signature","text":"","category":"section"},{"location":"scheduling/","page":"Scheduling","title":"Scheduling","text":"wait_for_all_tasks(scheduler::Scheduler)","category":"page"},{"location":"scheduling/#stop_task","page":"Scheduling","title":"stop_task","text":"","category":"section"},{"location":"scheduling/","page":"Scheduling","title":"Scheduling","text":"The stop_task function sends the stop signal to a task t. This will result in its completion once the next execution cycle is finished. If t is not stopable this will output a warning.","category":"page"},{"location":"scheduling/#Signature-3","page":"Scheduling","title":"Signature","text":"","category":"section"},{"location":"scheduling/","page":"Scheduling","title":"Scheduling","text":"stop_task(scheduler::Scheduler, t::Task)","category":"page"},{"location":"scheduling/#stop*all*tasks","page":"Scheduling","title":"stopalltasks","text":"","category":"section"},{"location":"scheduling/","page":"Scheduling","title":"Scheduling","text":"The stop_all_tasks function sends the stop signal to all stopable tasks. This will result in their completion once the next execution cycle is finished.","category":"page"},{"location":"scheduling/#Signature-4","page":"Scheduling","title":"Signature","text":"","category":"section"},{"location":"scheduling/","page":"Scheduling","title":"Scheduling","text":"stop_all_tasks(scheduler::Scheduler)","category":"page"},{"location":"scheduling/#stop*and*wait*for*all_tasks","page":"Scheduling","title":"stopandwaitforall_tasks","text":"","category":"section"},{"location":"scheduling/","page":"Scheduling","title":"Scheduling","text":"The stop_and_wait_for_all_tasks function sends the stop signal to all stopable tasks. It then waits for all scheduled tasks to finish.","category":"page"},{"location":"scheduling/#Signature-5","page":"Scheduling","title":"Signature","text":"","category":"section"},{"location":"scheduling/","page":"Scheduling","title":"Scheduling","text":"stop_and_wait_for_all_tasks(scheduler::Scheduler)","category":"page"},{"location":"encode_decode/#Mango.jl-Encoding-and-Decoding-(codec)-Feature-User-Documentation","page":"Codecs","title":"Mango.jl Encoding and Decoding (codec) Feature User Documentation","text":"","category":"section"},{"location":"encode_decode/","page":"Codecs","title":"Codecs","text":"Codecs provide functions for serializing and deserializing data to Mango containers. They use LightBSON.jl as their backend.","category":"page"},{"location":"encode_decode/","page":"Codecs","title":"Codecs","text":"As of now, the encode and decode functions forward their inputs directly to bson_read and bson_write. For most cases, we expect to pass messages as OrderedDict{String, Any}. We also forward an optional type field when decoding that is passed to bson_write to make use of the existing type-casting functionality here. For full information on what will work with this type of inference, we refer to the LightBSON.jl documentation.","category":"page"},{"location":"encode_decode/","page":"Codecs","title":"Codecs","text":"For future versions, we plan on adding a more convenient (but likely slower) type inference variant of the codec that saves necessary type information when encoding and iterates the output data while decoding to restore it exactly as it was before encoding (including type information).","category":"page"},{"location":"getting_started/#Getting-Started-with-Mango.jl","page":"Getting Started","title":"Getting Started with Mango.jl","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"In this getting started guide, we will explore the essential features of Mango.jl by creating a simple simulation of two ping pong agents that exchange messages in a container. We will set up a container with the TCP protocol, define ping pong agents, and enable them to exchange messages. You can also find working examples of the following code in examples.jl.","category":"page"},{"location":"getting_started/#.-Creating-a-Container-with-a-TCP-Protocol","page":"Getting Started","title":"1. Creating a Container with a TCP Protocol","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"To get started, we need to create a container to manage ping pong agents and facilitate communication using the TCP protocol:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"using Mango\n\n# Create the container instances with TCP protocol\ncontainer = create_tcp_container(\"127.0.0.1\", 5555)\ncontainer2 = create_tcp_container(\"127.0.0.1\", 5556)","category":"page"},{"location":"getting_started/#.-Defining-Ping-Pong-Agents","page":"Getting Started","title":"2. Defining Ping Pong Agents","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Let's define agent structs to represent the ping pong agents. Every new agent struct should be defined using the @agent macro to ensure compatibility with the mango container:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"using Mango\n\n# Define the ping pong agent\n@agent struct TCPPingPongAgent\n    counter::Int\nend","category":"page"},{"location":"getting_started/#.-Sending-and-Handling-Messages","page":"Getting Started","title":"3. Sending and Handling Messages","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Ping pong agents can exchange messages and they can keep track of the number of messages received. Let's implement message handling for the agents. To achieve this a new method handle_message from Mango has to be added:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"import Mango.handle_message\n\n# Override the default handle_message function for ping pong agents\nfunction handle_message(agent::TCPPingPongAgent, message::Any, meta::Any)\n    if message == \"Ping\"\n        agent.counter += 1\n        reply_to(agent, \"Pong\", meta)\n    elseif message == \"Pong\"\n        agent.counter += 1\n        reply_to(agent, \"Ping\", meta)\n    end\nend","category":"page"},{"location":"getting_started/#.-Sending-Messages","page":"Getting Started","title":"4. Sending Messages","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Now let's simulate the ping pong exchange by sending messages between the ping pong agents.  Addresses are provided to the send_message function via the AgentAddress struct. The struct consists of an aid and the more technical address field. Further an AgentAddress  can contain a tracking_id, which can identify the dialog agents are having.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"The send_message method here will automatically insert the agent as sender:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"# Define the ping pong agent\n# Create instances of ping pong agents\nping_agent = register(container, TCPPingPongAgent(0))\npong_agent = register(container2, TCPPingPongAgent(0))\n\nactivate([container, container2]) do\n    # Send the first message to start the exchange\n    send_message(ping_agent, \"Ping\", address(pong_agent))\n\n    # Wait for a moment to see the result\n    # In general you want to use a Condition() instead to\n    # Define a clear stopping signal for the agents\n    wait(Threads.@spawn begin\n        while ping_agent.counter < 5 \n            sleep(1)\n        end\n    end)\nend","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"In this example, the ping pong agents take turns sending \"Ping\" and \"Pong\" messages to each other, incrementing their counters. After a short moment, we can see the result of the ping pong process.","category":"page"},{"location":"getting_started/#.-Using-the-MQTT-Protocol","page":"Getting Started","title":"5. Using the MQTT Protocol","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"To use an MQTT messsage broker instead of a direkt TCP connection, you can use the the MQTT protocol.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"broker_addr = InetAddr(ip\"127.0.0.1\", 1883)\n\nc1 = create_mqtt_container(\"127.0.0.1\", 1883, \"PingContainer\")\nc2 = create_mqtt_container(\"127.0.0.1\", 1883, \"PongContainer\")","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"The topics each agent subscribes to on the broker are provided during registration to the container. All messages on these topics will then be forwarded as messages to the agent.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"# Define the ping pong agent\n@agent struct MQTTPingPongAgent\n    counter::Int\nend\n\n# Define the ping pong agent\n# Create instances of ping pong agents\n# register each agent to a container\n# For the MQTT protocol, topics for each agent have to be passed here.\nping_agent = register(c1, MQTTPingPongAgent(0); topics=[\"pongs\"])\npong_agent = register(c2, MQTTPingPongAgent(0); topics=[\"pings\"])","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Just like the TCPProtocol, the MQTTProtocol has an associated struct for providing address information:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"the broker address\nthe topic","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Thus, sending of the first message becomes:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"# Send the first message to start the exchange\nwait(send_message(ping_agent, \"Ping\", MQTTAddress(broker_addr, \"pings\")))","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Lastly, handle_message has to be altered to send the corresponding answers correctly:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"# Override the default handle_message function for ping pong agents\nfunction handle_message(agent::MQTTPingPongAgent, message::Any, meta::Any)\n    broker_addr = agent.context.container.protocol.broker_addr\n\n    if message == \"Ping\"\n        agent.counter += 1\n        send_message(agent, \"Pong\", MQTTAddress(broker_addr, \"pongs\"))\n    elseif message == \"Pong\"\n        agent.counter += 1\n        send_message(agent, \"Ping\", MQTTAddress(broker_addr, \"pings\"))\n    end\nend","category":"page"},{"location":"container/#Real-Time-Container","page":"Container","title":"Real Time Container","text":"","category":"section"},{"location":"container/","page":"Container","title":"Container","text":"The real time container feature in Mango.jl allows you to create and manage a container, which acts as the communication layer within the environment. A container is responsible for handling messages, forwarding them to the appropriate agents, and managing agent registration. The real time component means that the container acts on a real time clock, and does not differentiate between a simulation time and the execution time, which essentially means everything executed withing the real time container is executed immediately as stated in the code. In contrast, there is also a \"simulation\" container, which maintains an interal simulation time and only executes tasks and delivers messages according to the requested step_sizes (next event time). More on the simulation container can be found under Simulation Container. Note, that both container types implement the methods for the ContainerInterface and can therefore be drop-in replacements for the each other with slight differences in usage.","category":"page"},{"location":"container/#Container-Struct","page":"Container","title":"Container Struct","text":"","category":"section"},{"location":"container/","page":"Container","title":"Container","text":"The Container struct represents the container as an actor within the environment. It is implemented using composition, making it flexible to use different protocols and codecs for message communication. The key components of the Container struct are:","category":"page"},{"location":"container/","page":"Container","title":"Container","text":"protocol: The protocol used for message communication (e.g., TCP).\ncodec: A pair of functions for encoding and decoding messages in the container.","category":"page"},{"location":"container/#Start-and-Shutdown","page":"Container","title":"Start and Shutdown","text":"","category":"section"},{"location":"container/","page":"Container","title":"Container","text":"Before using the container for message handling and agent management, you need to start the container using the start function. This function initializes the container's components and enables it to act as the communication layer.","category":"page"},{"location":"container/","page":"Container","title":"Container","text":"using Mango\n\n# Create a container instance\ncontainer = Container()\n\n# ... setup the container, agents, define handles, ...\n\n# Start the container\nwait(Threads.@spwan start(container))\n\n# Execute some functionality to e.g. trigger the agent system\n\n# Shut down the container\nshutdown(container)","category":"page"},{"location":"container/","page":"Container","title":"Container","text":"However, this approach can be error-prone for multiple reasons. Besides simply forgetting to call shutdown, an exception may occur between the start and shutdown calls on the containers, leading to resource leaks. For this reason, we recommend using activate(runnable, containers). With this function, the above `start/shutdown' pair translates to...","category":"page"},{"location":"container/","page":"Container","title":"Container","text":"# Start the container and shut it down after the runnable (do ... end) has been executed.\nactivate(container) do\n\n# Execute some functionality to e.g. trigger the agent system\n\nend","category":"page"},{"location":"container/#Registering-Agents","page":"Container","title":"Registering Agents","text":"","category":"section"},{"location":"container/","page":"Container","title":"Container","text":"To enable the container to manage agents and handle their messaging activities, you can register agents using the register function. This function associates an agent with a unique agent ID (AID) and adds the agent to the container's internal list.","category":"page"},{"location":"container/","page":"Container","title":"Container","text":"using Mango\n\n# Create a container instance\ncontainer = Container()\n\n# Define and create an agent\n@agent struct MyAgent\n    # Your agent's fields and methods here\nend\n\nmy_agent = MyAgent()\n\n# Register the agent with the container\nregister(container, my_agent)","category":"page"},{"location":"container/#Sending-Messages","page":"Container","title":"Sending Messages","text":"","category":"section"},{"location":"container/","page":"Container","title":"Container","text":"To send messages between agents within the container, you can use the send_message function. The container routes the message to the specified receiver agent based on the receiver's AID.","category":"page"},{"location":"container/","page":"Container","title":"Container","text":"using Mango\n\n# Create a container instance\ncontainer = Container()\n\n# ... Register agents ...\n\n# Sending a message from one agent to another\nsend_message(container, \"Hello from Agent 1!\", \"agent2_id\")","category":"page"},{"location":"container/#TCP","page":"Container","title":"TCP","text":"","category":"section"},{"location":"container/","page":"Container","title":"Container","text":"This protocol allows communication over plain TCP connections, enabling message exchange between different entities within the Mango.jl simulation environment.","category":"page"},{"location":"container/#Introduction","page":"Container","title":"Introduction","text":"","category":"section"},{"location":"container/","page":"Container","title":"Container","text":"The TCP Protocol in Mango.jl is a communication protocol used to exchange messages over plain TCP connections. It enables agents within the simulation environment to communicate with each other by establishing and managing TCP connections.","category":"page"},{"location":"container/#TCPProtocol-Struct","page":"Container","title":"TCPProtocol Struct","text":"","category":"section"},{"location":"container/","page":"Container","title":"Container","text":"The TCPProtocol struct represents the TCP Protocol within Mango.jl. It encapsulates the necessary functionalities for communication via TCP connections. Key features of the TCPProtocol struct are:","category":"page"},{"location":"container/","page":"Container","title":"Container","text":"address: The InetAddr represents the address on which the TCP server listens.\nserver: A TCPServer instance used for accepting incoming connections.","category":"page"},{"location":"container/#Usage","page":"Container","title":"Usage","text":"","category":"section"},{"location":"container/","page":"Container","title":"Container","text":"To use the tcp protocol you need to construct a TCPProtocol struct and assign it to the protocol field in the container.","category":"page"},{"location":"container/","page":"Container","title":"Container","text":"container2 = Container()\ncontainer2.protocol = TCPProtocol(address=InetAddr(ip\"127.0.0.2\", 2940))","category":"page"},{"location":"container/","page":"Container","title":"Container","text":"It is also possible to use the convenience function create_tcp_container.","category":"page"},{"location":"container/#MQTT","page":"Container","title":"MQTT","text":"","category":"section"},{"location":"container/#Introduction-2","page":"Container","title":"Introduction","text":"","category":"section"},{"location":"container/","page":"Container","title":"Container","text":"The MQTT protocol enables sending via an MQTT message broker. It allows a container to subscribe to different topics on a broker and publish messages to them.","category":"page"},{"location":"container/","page":"Container","title":"Container","text":"Currently, one container may only connect to a single broker. Subscribed topics for each agent are set on agent registration and tracked by the container. Incoming messages on these topics are distributed to the subscribing agents by the container.","category":"page"},{"location":"container/#MQTTProtocol-Struct","page":"Container","title":"MQTTProtocol Struct","text":"","category":"section"},{"location":"container/","page":"Container","title":"Container","text":"The MQTTProtocol contains the status and channels of the underlying mosquitto C library (as abstracted to Julia by the Mosquitto.jl package).","category":"page"},{"location":"container/","page":"Container","title":"Container","text":"The constructor takes a client_id and the broker_addr. Internally it also tracks the msg_channel and conn_channel, internal flags, the information to map topics to subscribing agents.","category":"page"},{"location":"container/","page":"Container","title":"Container","text":"protocol = MQTTProtocol(cliant_id, broker_addr)","category":"page"},{"location":"container/","page":"Container","title":"Container","text":"client_id - String id the container will communicate to the MQTT broker.\nbroker_addr - InetAddr of the MQTT broker","category":"page"},{"location":"container/#Usage-2","page":"Container","title":"Usage","text":"","category":"section"},{"location":"container/","page":"Container","title":"Container","text":"To use the mqtt protocol you need to construct a MQTTProtocol struct and assign it to the protocol field in the container. Further it is possible to use a convenience function for this  It is also possible to use the convenience function create_mqtt_container.","category":"page"},{"location":"container/","page":"Container","title":"Container","text":"container2 = Container()\ncontainer2.protocol = MQTTProtocol(\"my_id\", InetAddr(ip\"127.0.0.2\", 2940))","category":"page"},{"location":"container/","page":"Container","title":"Container","text":"Subscribing an agent to a topic can happen only as registration time and is not allowed otherwise. When registering a new agent to the container the topics to subscribe are passed by the topics keyword argument, taking a collection of String topic names. NOTE: It is recommended you pass a Vector{String} as this is what is tested.  Other collections could work but no guarantees are given.","category":"page"},{"location":"container/","page":"Container","title":"Container","text":"a1 = MyAgent(0)\nregister(c1, a1; topics=[\"topic1\", \"topic2\"])","category":"page"},{"location":"#Mango.jl","page":"Home","title":"Mango.jl","text":"","category":"section"},{"location":"#Welcome-to-mango's-documentation!","page":"Home","title":"Welcome to mango's documentation!","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Mango.jl allows the user to create simple agents with little effort and at the same time offers options to structure agents with complex behaviour. The main features of mango are listed below.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Mango.jl as a package is partly based on the ideas of mango-agents, but will also contain new concepts and techniques. It was made with the picture of scalable agent simulations in mind.","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Container mechanism to speedup local message exchange\nStructuring complex agents with loose coupling and agent roles\nBuilt-in codecs\nSupports communication between agents directly via TCP and MQTT\nBuilt-in tasks mechanisms for proactive agent actions\nContinous and discrete stepping simulation using an external clock to rapidly run and inspect simulations designed for longer time-spans\nIntegrated communication and task simulation modules\nIntegrated environment with which the agents can interact in a common space","category":"page"},{"location":"#Development-state","page":"Home","title":"Development state","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Mango.jl is in an early development state. Feel free to try out the framework if you are interested and be aware that there might be some unexpected edges here and there.","category":"page"},{"location":"#License","page":"Home","title":"License","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Mango.jl is developed and published under the MIT license.","category":"page"},{"location":"agent/#Agents","page":"Agents","title":"Agents","text":"","category":"section"},{"location":"agent/","page":"Agents","title":"Agents","text":"Agents are autonomous entities that can perceive their environment, make decisions, and interact with other agents and the system they inhabit. They are the building blocks of Mango.jl, representing the individual entities or actors within a larger system.","category":"page"},{"location":"agent/#.-Agent-Definition-with-@agent-Macro","page":"Agents","title":"1. Agent Definition with @agent Macro","text":"","category":"section"},{"location":"agent/","page":"Agents","title":"Agents","text":"To define an agent the @agent macro can be used. It simplifies the process of defining an agent struct and automatically adds necessary baseline fields. Here's how you can define an agent:","category":"page"},{"location":"agent/","page":"Agents","title":"Agents","text":"using Mango\n\n# Define your agent struct using @agent macro\n@agent struct MyAgent\n    my_own_field::String\nend\n\n# Create an instance of the agent\nmy_agent = MyAgent(\"MyValue\")","category":"page"},{"location":"agent/","page":"Agents","title":"Agents","text":"The @agent macro adds the baseline fields listed in the table below. You can initialize the agent with exclusive fields like my_own_field in the example.","category":"page"},{"location":"agent/","page":"Agents","title":"Agents","text":"Field Description Usable?\naid The id of the agent Yes with aid(agent)!\ncontext Holds the reference to the container to send messages. Generally not recommended, use the convenience methods defined on the Agent type.\nscheduler The scheduler of the agent Generally not recommended, use the convenience methods defined on the Agent type.\nlock The agent lock to ensure only one message is handled per time. Internal use only!\nrole_handler Contains the roles and handles their interactions Internal use only!","category":"page"},{"location":"agent/#.-Role-Management","page":"Agents","title":"2. Role Management","text":"","category":"section"},{"location":"agent/","page":"Agents","title":"Agents","text":"Agents can have multiple roles associated with them. Roles can be added using the add function, allowing the agent to interact with its environment based on different roles. Here's how you can add roles to an agent:","category":"page"},{"location":"agent/","page":"Agents","title":"Agents","text":"using Mango\n\n# Define your role struct using @role macro\n@role struct MyRole\n    my_own_field::String\nend\n\n# Assume you have already defined roles using Mango.AgentRole module\nrole1 = MyRole(\"Role1\")\nrole2 = MyRole(\"Role2\")\n\n# Define your agent struct using @agent macro\n@agent struct MyAgent\n    my_own_field::String\nend\n\n# Create an instance of the agent\nmy_agent = MyAgent(\"MyValue\")\n\n# Add roles to the agent\nadd(my_agent, role1)\nadd(my_agent, role2)\n\n# Now you can interact with the roles as needed","category":"page"},{"location":"agent/","page":"Agents","title":"Agents","text":"As this can be clunky at some time, there is the possibility to create an agent using only roles and add it to the container using add_agent_composed_of.","category":"page"},{"location":"agent/","page":"Agents","title":"Agents","text":"# internally an empty agent definition is used, the roles are added and the agent\n# is added to the given container\ncreated_agent = add_agent_composed_of(your_container, RoleA(), RoleB(), RoleC())","category":"page"},{"location":"agent/","page":"Agents","title":"Agents","text":"For more information on roles, take a look at Role definition","category":"page"},{"location":"agent/#.-Message-Handling","page":"Agents","title":"3. Message Handling","text":"","category":"section"},{"location":"agent/","page":"Agents","title":"Agents","text":"Agents and Roles can handle incoming messages through the handle_message function. By default, it does nothing, but you can override it to define message-specific behavior. You can also add custom message handlers for specific roles using the subscribe_message function. Here's how to handle messages:","category":"page"},{"location":"agent/","page":"Agents","title":"Agents","text":"using Mango\n\n# Define your agent struct using @agent macro\n@agent struct MyAgent\n    my_own_field::String\nend\n@role struct MyRole\n    my_own_field::String\nend\n\n# Override the default handle_message function for custom behavior\nfunction handle_message(agent::MyAgent, message::Any, meta::Any)\n    println(\"Received message @agent: \", message)\nend\n# Override the default handle_message function for custom behavior\nfunction handle_message(role::MyRole, message::Any, meta::Any)\n    println(\"Received message @role: \", message)\nend","category":"page"},{"location":"agent/","page":"Agents","title":"Agents","text":"Besides the ability to handle messages, there also must be a possibility to send messages. This is implemented using the send_message function, defined on roles and agents.","category":"page"},{"location":"agent/","page":"Agents","title":"Agents","text":"using Mango\n\n# Define your agent struct using @agent macro\n@agent struct MyAgent\n    my_own_field::String\nend\n@role struct MyRole\n    my_own_field::String\nend\n\nagent = MyAgent(\"\")\nrole = MyAgent(\"\")\n\nsend_message(agent, \"Message\", AgentAddress(\"receiver_id\", \"receiver_addr\", \"optional tracking id\"))\nsend_message(role, \"Message\", AgentAddress(\"receiver_id\", \"receiver_addr\", \"optional tracking id\"))","category":"page"},{"location":"agent/","page":"Agents","title":"Agents","text":"Further, there are several specialized methods for sending messages, (1) send_tracked_message, (2) send_and_handle_answer, (3) reply_to, (4) forward_to.","category":"page"},{"location":"agent/","page":"Agents","title":"Agents","text":"(1) This function can be used to send a message with an automatically generated tracking id (uuid1) and it also accepts a response handler, which will     automatically be called when a response arrives to the tracked message (care to include the tracking id when responding or just use reply_to). (2) Variant of (1) which requires a response handler and enables the usage of the do syntax (see following code snippet). (3) Convenience function to respond to a received message without the need to create the AgentAddress by yourself. (4) Convenience function to forward messages to another agent. This function will set the approriate fields in the meta container to identify that a message has been forwarded and from which address it has been forwarded.","category":"page"},{"location":"agent/","page":"Agents","title":"Agents","text":"agent1 = MyAgent(\"\")\nagent2 = MyAgent(\"\")\nagent3 = MyAgent(\"\")\n\nfunction handle_message(agent::MyAgent, message::Any, meta::Any)\n    # agent 2\n    reply_to(agent, \"Hello Agent, this is a response\", meta) # (3)\nend\nfunction handle_response(agent::MyAgent, message::Any, meta::Any)\n    # agent 1\n    forward_to(agent, \"Forwarded message\", address(agent3), meta) # (4)\nend\n\nsend_tracked_message(agent1, \"Hello Agent, this is a tracked message\", AgentAddress(aid=agent2.aid); response_handler=handle_response) # (1)\nsend_and_handle_answer(agent1, \"Hello Agent, this is a different tracked message\", AgentAddress(aid=agent2.aid)) do agent, message, meta # (2)\n    # agent 1\nend","category":"page"},{"location":"agent/","page":"Agents","title":"Agents","text":"There is also a possibility to enable automatic forwarding with adding so-called forwarding rules. For this you can use the function add_forwarding_rule(agent, from, to, forward_replies). To delete these rules the function delete_forwarding_rule(agent, from, to=nothing) exists.","category":"page"},{"location":"agent/#.-Task-Scheduling","page":"Agents","title":"4. Task Scheduling","text":"","category":"section"},{"location":"agent/","page":"Agents","title":"Agents","text":"Agents can schedule tasks using the schedule function, which delegates to the Mango.schedule function. You can wait for all scheduled tasks to be completed using wait_for_all_tasks. Here's how to schedule tasks:","category":"page"},{"location":"agent/","page":"Agents","title":"Agents","text":"using Mango\n\n# Define your agent struct using @agent macro\n@agent struct MyAgent\n    my_own_field::String\nend\n\n# Create an instance of the agent\nmy_agent = MyAgent(\"MyValue\")\n\n# Schedule a task for the agent\nschedule(my_task_function, my_agent, PeriodicTaskData(5.0)) # Schedule a task to run every 5 seconds\n\n# Wait for all scheduled tasks to complete\nwait_for_all_tasks(my_agent)","category":"page"},{"location":"legals/#Legals","page":"Legals","title":"Legals","text":"","category":"section"},{"location":"legals/","page":"Legals","title":"Legals","text":"Address","category":"page"},{"location":"legals/","page":"Legals","title":"Legals","text":"OFFIS e. V.   Escherweg 2   26121 Oldenburg   Germany   Phone +49 441 9722-0   Fax +49 441 9722-102   Email: institut [ A T ] offis.de   Internet: www.offis.de  ","category":"page"},{"location":"legals/","page":"Legals","title":"Legals","text":"Board Members","category":"page"},{"location":"legals/","page":"Legals","title":"Legals","text":"Prof. Dr. Sebastian Lehnhoff (Chairman)   Prof. Dr. techn. Susanne Boll-Westermann   Prof. Dr.-Ing. Andreas Hein   Prof. Dr.-Ing. Astrid Nieße","category":"page"},{"location":"legals/","page":"Legals","title":"Legals","text":"Register Court","category":"page"},{"location":"legals/","page":"Legals","title":"Legals","text":"Amtsgericht Oldenburg   Registernumber VR 1956","category":"page"},{"location":"legals/","page":"Legals","title":"Legals","text":"VAT Identification Number","category":"page"},{"location":"legals/","page":"Legals","title":"Legals","text":"DE 811582102","category":"page"},{"location":"legals/","page":"Legals","title":"Legals","text":"Responsible in the sense of press law","category":"page"},{"location":"legals/","page":"Legals","title":"Legals","text":"Dr. Ing. Jürgen Meister (Director)   OFFIS e.V.   Escherweg 2   26121 Oldenburg  ","category":"page"},{"location":"legals/","page":"Legals","title":"Legals","text":"Disclaimer","category":"page"},{"location":"legals/","page":"Legals","title":"Legals","text":"Despite careful control OFFIS assumes no liability for the content of external links. The operators of such a website are solely responsible for its content. At the time of linking the concerned sites were checked for possible violations of law. Illegal contents were not identifiable at that time. A permanent control of the linked pages is not reasonable without specific indications of a violation. Upon notification of violations, OFFIS will remove such links immediately.","category":"page"}]
}
