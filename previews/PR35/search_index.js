var documenterSearchIndex = {"docs":
[{"location":"scheduling/#Scheduling","page":"Scheduling","title":"Scheduling","text":"","category":"section"},{"location":"scheduling/#.-Introduction","page":"Scheduling","title":"1. Introduction","text":"","category":"section"},{"location":"scheduling/","page":"Scheduling","title":"Scheduling","text":"Welcome to the documentation for the Scheduling component in Mango.jl. This utility component provides a flexible scheduler for executing predefined tasks. It offers various TaskData types to specify different task execution behaviors.","category":"page"},{"location":"scheduling/#.-Module-Overview","page":"Scheduling","title":"2. Module Overview","text":"","category":"section"},{"location":"scheduling/","page":"Scheduling","title":"Scheduling","text":"The Scheduling module exports several types and functions to facilitate task scheduling and execution. Let's briefly review the main components of this module.","category":"page"},{"location":"scheduling/#Task-Data-Types","page":"Scheduling","title":"Task Data Types","text":"","category":"section"},{"location":"scheduling/","page":"Scheduling","title":"Scheduling","text":"The module provides different TaskData types, each catering to specific scheduling requirements:","category":"page"},{"location":"scheduling/","page":"Scheduling","title":"Scheduling","text":"PeriodicTaskData: For tasks that need to be executed periodically, it holds the time interval in seconds between task executions.\nInstantTaskData: For tasks that need to be executed instantly, without any delay.\nDateTimeTaskData: For tasks that need to be executed at a specific date and time.\nAwaitableTaskData: For tasks that require waiting for an awaitable object to complete before execution.\nConditionalTaskData: For tasks that execute based on a specific condition at regular intervals.","category":"page"},{"location":"scheduling/#Typical-usage","page":"Scheduling","title":"Typical usage","text":"","category":"section"},{"location":"scheduling/","page":"Scheduling","title":"Scheduling","text":"Typically the scheduler is used within methods from the agent. To schedule a task the function schedule can be used. It takes two inputs: The agent (which forwards the call to its scheduler) and the TaskData object of the task.","category":"page"},{"location":"scheduling/","page":"Scheduling","title":"Scheduling","text":"agent = MyAgent(0)\nresult = 0\n\nschedule(agent, InstantTaskData()) do \n    # some expensive calculation\n    result = 10       \nend\nwait_for_all_tasks(agent)","category":"page"},{"location":"scheduling/","page":"Scheduling","title":"Scheduling","text":"PeriodicTaskData creates tasks that get executed repeatedly forever.  This means that calling wait on such a task will generally simply block forever. For this reason a periodic task has to be stopped before it can be waited on.","category":"page"},{"location":"scheduling/","page":"Scheduling","title":"Scheduling","text":"delay_in_s = 0.5 # delay between executions of the task in seconds\n\nt = schedule(agent, PeriodicTaskData(delay)) do \n    # some expensive calculation\n    result = 10       \nend\n\nstop_task(agent, t)\nwait_for_all_tasks(agent)","category":"page"},{"location":"scheduling/","page":"Scheduling","title":"Scheduling","text":"Alternatively, you can stop all stopable tasks simultaneously with the stop_all_tasks function.","category":"page"},{"location":"scheduling/","page":"Scheduling","title":"Scheduling","text":"delay_in_s = 0.5 # delay between executions of the task in seconds\n\nfor i in 1:100\n    schedule(agent, PeriodicTaskData(delay)) do \n        # some expensive calculation\n        result = 10       \n    end\nend\n\nstop_all_task(agent, t)\nwait_for_all_tasks(agent)","category":"page"},{"location":"scheduling/","page":"Scheduling","title":"Scheduling","text":"Finally, stop_and_wait_for_all_tasks is a convenience methods combining both stop_all_tasks and wait_for_all_tasks.","category":"page"},{"location":"scheduling/#.-Scheduler","page":"Scheduling","title":"3. Scheduler","text":"","category":"section"},{"location":"scheduling/","page":"Scheduling","title":"Scheduling","text":"The Scheduler type is an internal structure that holds a collection of tasks to be scheduled and executed. Every agent contains such a scheduler struct by default and implements methods for convenient delegation.","category":"page"},{"location":"scheduling/#Structure","page":"Scheduling","title":"Structure","text":"","category":"section"},{"location":"scheduling/","page":"Scheduling","title":"Scheduling","text":"struct Scheduler\n    tasks::Vector{Task}\nend","category":"page"},{"location":"scheduling/#.-Functions","page":"Scheduling","title":"4. Functions","text":"","category":"section"},{"location":"scheduling/#execute_task","page":"Scheduling","title":"execute_task","text":"","category":"section"},{"location":"scheduling/","page":"Scheduling","title":"Scheduling","text":"The execute_task function executes a task with a specific TaskData.","category":"page"},{"location":"scheduling/#Signatures","page":"Scheduling","title":"Signatures","text":"","category":"section"},{"location":"scheduling/","page":"Scheduling","title":"Scheduling","text":"execute_task(f::Function, data::PeriodicTaskData)\nexecute_task(f::Function, data::InstantTaskData)\nexecute_task(f::Function, data::DateTimeTaskData)\nexecute_task(f::Function, data::AwaitableTaskData)\nexecute_task(f::Function, data::ConditionalTaskData)","category":"page"},{"location":"scheduling/#schedule","page":"Scheduling","title":"schedule","text":"","category":"section"},{"location":"scheduling/","page":"Scheduling","title":"Scheduling","text":"The schedule function adds a task to the scheduler with the specified TaskData and scheduling type.","category":"page"},{"location":"scheduling/#Signature","page":"Scheduling","title":"Signature","text":"","category":"section"},{"location":"scheduling/","page":"Scheduling","title":"Scheduling","text":"schedule(f::Function, scheduler::Union{Scheduler,Agent}, data::TaskData, scheduling_type::SchedulingType=ASYNC)","category":"page"},{"location":"scheduling/#wait*for*all_tasks","page":"Scheduling","title":"waitforall_tasks","text":"","category":"section"},{"location":"scheduling/","page":"Scheduling","title":"Scheduling","text":"The wait_for_all_tasks function waits for all the scheduled tasks in the provided scheduler to complete.","category":"page"},{"location":"scheduling/#Signature-2","page":"Scheduling","title":"Signature","text":"","category":"section"},{"location":"scheduling/","page":"Scheduling","title":"Scheduling","text":"wait_for_all_tasks(scheduler::Scheduler)","category":"page"},{"location":"scheduling/#stop_task","page":"Scheduling","title":"stop_task","text":"","category":"section"},{"location":"scheduling/","page":"Scheduling","title":"Scheduling","text":"The stop_task function sends the stop signal to a task t. This will result in its completion once the next execution cycle is finished. If t is not stopable this will output a warning.","category":"page"},{"location":"scheduling/#Signature-3","page":"Scheduling","title":"Signature","text":"","category":"section"},{"location":"scheduling/","page":"Scheduling","title":"Scheduling","text":"stop_task(scheduler::Scheduler, t::Task)","category":"page"},{"location":"scheduling/#stop*all*tasks","page":"Scheduling","title":"stopalltasks","text":"","category":"section"},{"location":"scheduling/","page":"Scheduling","title":"Scheduling","text":"The stop_all_tasks function sends the stop signal to all stopable tasks. This will result in their completion once the next execution cycle is finished.","category":"page"},{"location":"scheduling/#Signature-4","page":"Scheduling","title":"Signature","text":"","category":"section"},{"location":"scheduling/","page":"Scheduling","title":"Scheduling","text":"stop_all_tasks(scheduler::Scheduler)","category":"page"},{"location":"scheduling/#stop*and*wait*for*all_tasks","page":"Scheduling","title":"stopandwaitforall_tasks","text":"","category":"section"},{"location":"scheduling/","page":"Scheduling","title":"Scheduling","text":"The stop_and_wait_for_all_tasks function sends the stop signal to all stopable tasks. It then waits for all scheduled tasks to finish.","category":"page"},{"location":"scheduling/#Signature-5","page":"Scheduling","title":"Signature","text":"","category":"section"},{"location":"scheduling/","page":"Scheduling","title":"Scheduling","text":"stop_and_wait_for_all_tasks(scheduler::Scheduler)","category":"page"},{"location":"encode_decode/#Mango.jl-Encoding-and-Decoding-(codec)-Feature-User-Documentation","page":"Codecs","title":"Mango.jl Encoding and Decoding (codec) Feature User Documentation","text":"","category":"section"},{"location":"encode_decode/","page":"Codecs","title":"Codecs","text":"Codecs provide functions for serializing and deserializing data to Mango containers. They use LightBSON.jl as their backend.","category":"page"},{"location":"encode_decode/","page":"Codecs","title":"Codecs","text":"As of now, the encode and decode functions forward their inputs directly to bson_read and bson_write. For most cases, we expect to pass messages as OrderedDict{String, Any}. We also forward an optional type field when decoding that is passed to bson_write to make use of the existing type-casting functionality here. For full information on what will work with this type of inference, we refer to the LightBSON.jl documentation.","category":"page"},{"location":"encode_decode/","page":"Codecs","title":"Codecs","text":"For future versions, we plan on adding a more convenient (but likely slower) type inference variant of the codec that saves necessary type information when encoding and iterates the output data while decoding to restore it exactly as it was before encoding (including type information).","category":"page"},{"location":"getting_started/#Getting-Started-with-Mango.jl","page":"Getting Started","title":"Getting Started with Mango.jl","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"In this getting started guide, we will explore the essential features of Mango.jl by creating a simple simulation of two ping pong agents that exchange messages in a container. We will set up a container with the TCP protocol, define ping pong agents, and enable them to exchange messages.","category":"page"},{"location":"getting_started/#.-Creating-a-Container-with-a-Protocol","page":"Getting Started","title":"1. Creating a Container with a Protocol","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"To get started, we need to create a container to manage ping pong agents and facilitate communication using the TCP protocol:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"using Mango\n\n# Create the container instances with TCP protocol\ncontainer = Container()\ncontainer.protocol = TCPProtocol(address=InetAddr(ip\"127.0.0.2\", 2980))\n\ncontainer2 = Container()\ncontainer2.protocol = TCPProtocol(address=InetAddr(ip\"127.0.0.2\", 2981))\n\n# Start the container\nwait(Threads.@spawn start(container))\nwait(Threads.@spawn start(container2))","category":"page"},{"location":"getting_started/#.-Defining-Ping-Pong-Agents","page":"Getting Started","title":"2. Defining Ping Pong Agents","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Let's define agent structs to represent the ping pong agents. Every new agent struct should be defined using the @agent macro to ensure compatibility with the mango container:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"using Mango\n\n# Define the ping pong agent\n@agent struct PingPongAgent\n    counter::Int\nend","category":"page"},{"location":"getting_started/#.-Sending-and-Handling-Messages","page":"Getting Started","title":"3. Sending and Handling Messages","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Ping pong agents can exchange messages and they can keep track of the number of messages received. Let's implement message handling for the agents. To achieve this a new method handle_message from Mango has to be added:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"import Mango.handle_message\n\n# Override the default handle_message function for ping pong agents\nfunction handle_message(agent::PingPongAgent, message::Any, meta::Dict)\n    if message == \"Ping\"\n        agent.counter += 1\n        send_message(agent, \"Pong\", meta[\"sender_id\"], meta[\"sender_addr\"])\n    elseif message == \"Pong\"\n        agent.counter += 1\n        send_message(agent, \"Ping\", meta[\"sender_id\"], meta[\"sender_addr\"])\n    end\nend","category":"page"},{"location":"getting_started/#.-Sending-Messages","page":"Getting Started","title":"4. Sending Messages","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Now let's simulate the ping pong exchange by sending messages between the ping pong agents. The send_message method here will automatically insert the agent as sender:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"# Define the ping pong agent\n# Create instances of ping pong agents\nping_agent = PingPongAgent(0)\npong_agent = PingPongAgent(0)\n\n# Send the first message to start the exchange\nsend_message(ping_agent, \"Ping\", pong_agent.aid, InetAddr(ip\"127.0.0.2\", 2980))\n\n# Wait for a moment to see the result\n# In general you want to use a Condition() instead to\n# Define a clear stopping signal for the agents\nwait(Threads.@spawn begin\n    while ping_agent.counter < 5 \n        sleep(1)\n    end\nend)\n\n@sync begin\n    Threads.@spawn shutdown(container)\n    Threads.@spawn shutdown(container2)\nend","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"In this example, the ping pong agents take turns sending \"Ping\" and \"Pong\" messages to each other, incrementing their counters. After a short moment, we can see the result of the ping pong process.","category":"page"},{"location":"container/#Mango.jl-Container-Feature-User-Documentation","page":"Container","title":"Mango.jl Container Feature User Documentation","text":"","category":"section"},{"location":"container/","page":"Container","title":"Container","text":"Welcome to the user documentation for the Container feature in Mango.jl! This module is a fundamental part of the Mango.jl framework, providing functionalities for managing agents, handling messages, and enabling communication within the simulation environment.","category":"page"},{"location":"container/#.-Introduction","page":"Container","title":"1. Introduction","text":"","category":"section"},{"location":"container/","page":"Container","title":"Container","text":"The Container feature in Mango.jl allows you to create and manage a container, which acts as the communication layer within the simulation environment. The container is responsible for handling messages, forwarding them to the appropriate agents, and managing agent registration.","category":"page"},{"location":"container/#.-Container-Struct","page":"Container","title":"2. Container Struct","text":"","category":"section"},{"location":"container/","page":"Container","title":"Container","text":"The Container struct represents the container as an actor within the simulation. It is implemented using composition, making it flexible to use different protocols and codecs for message communication. The key components of the Container struct are:","category":"page"},{"location":"container/","page":"Container","title":"Container","text":"protocol: The protocol used for message communication (e.g., TCP).\ncodec: A pair of functions for encoding and decoding messages in the container.","category":"page"},{"location":"container/#.-Start-and-Shutdown","page":"Container","title":"3. Start and Shutdown","text":"","category":"section"},{"location":"container/","page":"Container","title":"Container","text":"Before using the container for message handling and agent management, you need to start the container using the start function. This function initializes the container's components and enables it to act as the communication layer.","category":"page"},{"location":"container/","page":"Container","title":"Container","text":"using Mango\n\n# Create a container instance\ncontainer = Container()\n\n# Start the container\nwait(Threads.@spwan start(container))\n\n# ... Perform message handling and agent registration ...\n# ... When done, shut down the container ...\n\n# Shut down the container\nshutdown(container)","category":"page"},{"location":"container/#.-Registering-Agents","page":"Container","title":"4. Registering Agents","text":"","category":"section"},{"location":"container/","page":"Container","title":"Container","text":"To enable the container to manage agents and handle their messaging activities, you can register agents using the register function. This function associates an agent with a unique agent ID (AID) and adds the agent to the container's internal list.","category":"page"},{"location":"container/","page":"Container","title":"Container","text":"using Mango\n\n# Create a container instance\ncontainer = Container()\n\n# Define and create an agent\n@agent struct MyAgent\n    # Your agent's fields and methods here\nend\n\nmy_agent = MyAgent()\n\n# Register the agent with the container\nregister(container, my_agent)","category":"page"},{"location":"container/#.-Sending-Messages","page":"Container","title":"5. Sending Messages","text":"","category":"section"},{"location":"container/","page":"Container","title":"Container","text":"To send messages between agents within the container, you can use the send_message function. The container routes the message to the specified receiver agent based on the receiver's AID.","category":"page"},{"location":"container/","page":"Container","title":"Container","text":"using Mango\n\n# Create a container instance\ncontainer = Container()\n\n# ... Register agents ...\n\n# Sending a message from one agent to another\nsend_message(container, \"Hello from Agent 1!\", \"agent2_id\")","category":"page"},{"location":"container/#.-TCP","page":"Container","title":"6. TCP","text":"","category":"section"},{"location":"container/","page":"Container","title":"Container","text":"This protocol allows communication over plain TCP connections, enabling message exchange between different entities within the Mango.jl simulation environment.","category":"page"},{"location":"container/#.-Introduction-2","page":"Container","title":"1. Introduction","text":"","category":"section"},{"location":"container/","page":"Container","title":"Container","text":"The TCP Protocol in Mango.jl is a communication protocol used to exchange messages over plain TCP connections. It enables agents within the simulation environment to communicate with each other by establishing and managing TCP connections.","category":"page"},{"location":"container/#.-TCPProtocol-Struct","page":"Container","title":"2. TCPProtocol Struct","text":"","category":"section"},{"location":"container/","page":"Container","title":"Container","text":"The TCPProtocol struct represents the TCP Protocol within Mango.jl. It encapsulates the necessary functionalities for communication via TCP connections. Key features of the TCPProtocol struct are:","category":"page"},{"location":"container/","page":"Container","title":"Container","text":"address: The InetAddr represents the address on which the TCP server listens.\nserver: A TCPServer instance used for accepting incoming connections.","category":"page"},{"location":"container/#.-Usage","page":"Container","title":"3. Usage","text":"","category":"section"},{"location":"container/","page":"Container","title":"Container","text":"To use the tcp protocol you need to construct a TCPProtocol struct and assign it to the protocol field in the container.","category":"page"},{"location":"container/","page":"Container","title":"Container","text":"container2 = Container()\ncontainer2.protocol = TCPProtocol(address=InetAddr(ip\"127.0.0.2\", 2940))","category":"page"},{"location":"#Mango.jl","page":"Home","title":"Mango.jl","text":"","category":"section"},{"location":"#Welcome-to-mango's-documentation!","page":"Home","title":"Welcome to mango's documentation!","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Mango.jl allows the user to create simple agents with little effort and at the same time offers options to structure agents with complex behaviour. The main features of mango are listed below.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Mango.jl as a package is partly based on the ideas of mango-agents, but will also contain new concepts and techniques. It was made with the picture of scalable agent simulations in mind.","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Container mechanism to speedup local message exchange\nStructuring complex agents with loose coupling and agent roles\nBuilt-in codecs\nSupports communication between agents directly via TCP","category":"page"},{"location":"#Development-state","page":"Home","title":"Development state","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Mango.jl is in an early development state. Feel free to try out the framework if you are interested and be aware that there might be some unexpected edges here and there.","category":"page"},{"location":"#License","page":"Home","title":"License","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Mango.jl is developed and published under the MIT license.","category":"page"},{"location":"agent/#Agents","page":"Agents","title":"Agents","text":"","category":"section"},{"location":"agent/","page":"Agents","title":"Agents","text":"Agents are autonomous entities that can perceive their environment, make decisions, and interact with other agents and the system they inhabit. They are the building blocks of Mango.jl, representing the individual entities or actors within a larger system.","category":"page"},{"location":"agent/#.-Agent-Definition-with-@agent-Macro","page":"Agents","title":"1. Agent Definition with @agent Macro","text":"","category":"section"},{"location":"agent/","page":"Agents","title":"Agents","text":"To define an agent the @agent macro can be used. It simplifies the process of defining an agent struct and automatically adds necessary baseline fields. Here's how you can define an agent:","category":"page"},{"location":"agent/","page":"Agents","title":"Agents","text":"using Mango\n\n# Define your agent struct using @agent macro\n@agent struct MyAgent\n    my_own_field::String\nend\n\n# Create an instance of the agent\nmy_agent = MyAgent(\"MyValue\")","category":"page"},{"location":"agent/","page":"Agents","title":"Agents","text":"The @agent macro adds the baseline fields listed in the table below. You can initialize the agent with exclusive fields like my_own_field in the example.","category":"page"},{"location":"agent/","page":"Agents","title":"Agents","text":"Field Description Usable?\naid The id of the agent Yes with aid(agent)!\ncontext Holds the reference to the container to send messages. Generally not recommended, use the convenience methods defined on the Agent type.\nscheduler The scheduler of the agent Generally not recommended, use the convenience methods defined on the Agent type.\nlock The agent lock to ensure only one message is handled per time. Internal use only!\nrole_handler Contains the roles and handles their interactions Internal use only!","category":"page"},{"location":"agent/#.-Role-Management","page":"Agents","title":"2. Role Management","text":"","category":"section"},{"location":"agent/","page":"Agents","title":"Agents","text":"Agents can have multiple roles associated with them. Roles can be added using the add function, allowing the agent to interact with its environment based on different roles. Here's how you can add roles to an agent:","category":"page"},{"location":"agent/","page":"Agents","title":"Agents","text":"using Mango\n\n# Define your agent struct using @agent macro\n@role struct MyRole\n    my_own_field::String\nend\n\n# Assume you have already defined roles using Mango.AgentRole module\nrole1 = MyRole(\"Role1\")\nrole2 = MyRole(\"Role2\")\n\n# Define your agent struct using @agent macro\n@agent struct MyAgent\n    my_own_field::String\nend\n\n# Create an instance of the agent\nmy_agent = MyAgent(\"MyValue\")\n\n# Add roles to the agent\nadd(my_agent, role1)\nadd(my_agent, role2)\n\n# Now you can interact with the roles as needed","category":"page"},{"location":"agent/","page":"Agents","title":"Agents","text":"Additionally, roles can define the setup function to define actions to take when the roles are added to the agent. It is also possible to subscribe to specific messages using a boolean expression with the subscribe(role::Role, handler::Function, condition::Function) function. With the @role macro, the role context is added to the role, which contains the reference to the agent. However, it is recommended to use the equivalent methods defined on the role to execute actions like scheduling and sending messages.","category":"page"},{"location":"agent/#.-Message-Handling","page":"Agents","title":"3. Message Handling","text":"","category":"section"},{"location":"agent/","page":"Agents","title":"Agents","text":"Agents and Roles can handle incoming messages through the handle_message function. By default, it does nothing, but you can override it to define message-specific behavior. You can also add custom message handlers for specific roles using the subscribe_handle function. Here's how to handle messages:","category":"page"},{"location":"agent/","page":"Agents","title":"Agents","text":"using Mango\n\n# Define your agent struct using @agent macro\n@agent struct MyAgent\n    my_own_field::String\nend\n@role struct MyRole\n    my_own_field::String\nend\n\n# Override the default handle_message function for custom behavior\nfunction handle_message(agent::MyAgent, message::Any, meta::Any)\n    println(\"Received message @agent: \", message)\nend\n# Override the default handle_message function for custom behavior\nfunction handle_message(role::MyRole, message::Any, meta::Any)\n    println(\"Received message @role: \", message)\nend","category":"page"},{"location":"agent/","page":"Agents","title":"Agents","text":"Besides the ability to handle messages, there also must be a possibility to send messages. This is implemented using the send_message function, defined on roles and agents.","category":"page"},{"location":"agent/","page":"Agents","title":"Agents","text":"using Mango\n\n# Define your agent struct using @agent macro\n@agent struct MyAgent\n    my_own_field::String\nend\n@role struct MyRole\n    my_own_field::String\nend\n\nagent = MyAgent(\"\")\nrole = MyAgent(\"\")\n\nsend_message(agent, \"Message\", AgentAddress(\"receiver_id\", \"receiver_addr\", \"optional tracking id\"))\nsend_message(role, \"Message\", AgentAddress(\"receiver_id\", \"receiver_addr\", \"optional tracking id\"))","category":"page"},{"location":"agent/","page":"Agents","title":"Agents","text":"Further, there are two specialized methods for sending methods, (1) send_tracked_message and (2) reply_to.","category":"page"},{"location":"agent/","page":"Agents","title":"Agents","text":"(1) This function can be used to send a message with an automatically generated tracking id (uuid1) and it also accepts a response handler, which will     automatically be called when a response arrives to the tracked message (care to include the tracking id when responding or just use reply_to). (2) Convenience function to respond to a received message without the need to create the AgentAddress by yourself.","category":"page"},{"location":"agent/","page":"Agents","title":"Agents","text":"agent1 = MyAgent(\"\")\nagent2 = MyAgent(\"\")\n\nfunction handle_message(agent::MyAgent, message::Any, meta::Any)\n    # agent 2\n    reply_to(agent, \"Hello Agent, this is a response\", meta) # (2)\nend\nfunction handle_response(agent::MyAgent, message::Any, meta::Any)\n    # agent 1\nend\n\nsend_tracked_message(agent1, \"Hello Agent, this is a tracked message\", AgentAddress(aid=agent2.aid); response_handler=handle_response) # (1)","category":"page"},{"location":"agent/#.-Task-Scheduling","page":"Agents","title":"4. Task Scheduling","text":"","category":"section"},{"location":"agent/","page":"Agents","title":"Agents","text":"Agents can schedule tasks using the schedule function, which delegates to the Mango.schedule function. You can wait for all scheduled tasks to be completed using wait_for_all_tasks. Here's how to schedule tasks:","category":"page"},{"location":"agent/","page":"Agents","title":"Agents","text":"using Mango\n\n# Define your agent struct using @agent macro\n@agent struct MyAgent\n    my_own_field::String\nend\n\n# Create an instance of the agent\nmy_agent = MyAgent(\"MyValue\")\n\n# Schedule a task for the agent\nschedule(my_task_function, my_agent, PeriodicTaskData(5.0)) # Schedule a task to run every 5 seconds\n\n# Wait for all scheduled tasks to complete\nwait_for_all_tasks(my_agent)","category":"page"},{"location":"legals/#Legals","page":"Legals","title":"Legals","text":"","category":"section"},{"location":"legals/","page":"Legals","title":"Legals","text":"Address","category":"page"},{"location":"legals/","page":"Legals","title":"Legals","text":"OFFIS e. V.   Escherweg 2   26121 Oldenburg   Germany   Phone +49 441 9722-0   Fax +49 441 9722-102   Email: institut [ A T ] offis.de   Internet: www.offis.de  ","category":"page"},{"location":"legals/","page":"Legals","title":"Legals","text":"Board Members","category":"page"},{"location":"legals/","page":"Legals","title":"Legals","text":"Prof. Dr. Sebastian Lehnhoff (Chairman)   Prof. Dr. techn. Susanne Boll-Westermann   Prof. Dr.-Ing. Andreas Hein   Prof. Dr.-Ing. Astrid Nieße","category":"page"},{"location":"legals/","page":"Legals","title":"Legals","text":"Register Court","category":"page"},{"location":"legals/","page":"Legals","title":"Legals","text":"Amtsgericht Oldenburg   Registernumber VR 1956","category":"page"},{"location":"legals/","page":"Legals","title":"Legals","text":"VAT Identification Number","category":"page"},{"location":"legals/","page":"Legals","title":"Legals","text":"DE 811582102","category":"page"},{"location":"legals/","page":"Legals","title":"Legals","text":"Responsible in the sense of press law","category":"page"},{"location":"legals/","page":"Legals","title":"Legals","text":"Dr. Ing. Jürgen Meister (Director)   OFFIS e.V.   Escherweg 2   26121 Oldenburg  ","category":"page"},{"location":"legals/","page":"Legals","title":"Legals","text":"Disclaimer","category":"page"},{"location":"legals/","page":"Legals","title":"Legals","text":"Despite careful control OFFIS assumes no liability for the content of external links. The operators of such a website are solely responsible for its content. At the time of linking the concerned sites were checked for possible violations of law. Illegal contents were not identifiable at that time. A permanent control of the linked pages is not reasonable without specific indications of a violation. Upon notification of violations, OFFIS will remove such links immediately.","category":"page"}]
}
