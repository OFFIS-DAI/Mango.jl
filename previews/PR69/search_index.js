var documenterSearchIndex = {"docs":
[{"location":"scheduling/#Scheduling","page":"Scheduling","title":"Scheduling","text":"","category":"section"},{"location":"scheduling/","page":"Scheduling","title":"Scheduling","text":"The Scheduling module exports several types and functions to facilitate task scheduling and execution. Let's briefly review the main components of this module.","category":"page"},{"location":"scheduling/#Task-Data-Types","page":"Scheduling","title":"Task Data Types","text":"","category":"section"},{"location":"scheduling/","page":"Scheduling","title":"Scheduling","text":"The module provides different TaskData types, each catering to specific scheduling requirements:","category":"page"},{"location":"scheduling/","page":"Scheduling","title":"Scheduling","text":"PeriodicTaskData: For tasks that need to be executed periodically, it holds the time interval in seconds between task executions.\nInstantTaskData: For tasks that need to be executed instantly, without any delay.\nDateTimeTaskData: For tasks that need to be executed at a specific date and time.\nAwaitableTaskData: For tasks that require waiting for an awaitable object to complete before execution.\nConditionalTaskData: For tasks that execute based on a specific condition at regular intervals.","category":"page"},{"location":"scheduling/#Typical-usage","page":"Scheduling","title":"Typical usage","text":"","category":"section"},{"location":"scheduling/","page":"Scheduling","title":"Scheduling","text":"Typically the scheduler is used within methods from the agent. To schedule a task the function schedule can be used. It takes two inputs: The agent (which forwards the call to its scheduler) and the TaskData object of the task.","category":"page"},{"location":"scheduling/","page":"Scheduling","title":"Scheduling","text":"using Mango\n\n@agent struct MyAgent end\nagent = MyAgent()\nresult = 0\n\nt = schedule(agent, InstantTaskData()) do \n    # some expensive calculation\n    result = 10       \nend\n\nwait(t)","category":"page"},{"location":"scheduling/","page":"Scheduling","title":"Scheduling","text":"PeriodicTaskData creates tasks that get executed repeatedly forever.  This means that calling wait on such a task will generally simply block forever. For this reason a periodic task has to be stopped before it can be waited on.","category":"page"},{"location":"scheduling/","page":"Scheduling","title":"Scheduling","text":"delay_in_s = 0.1 # delay between executions of the task in seconds\nresult = 0\n\nt = schedule(agent, PeriodicTaskData(delay_in_s)) do \n    # some expensive calculation\n    println(\"iterated\") \nend\n\nsleep(0.2)\nstop_task(agent, t)\nwait_for_all_tasks(agent)","category":"page"},{"location":"scheduling/","page":"Scheduling","title":"Scheduling","text":"Alternatively, you can stop all stopable tasks simultaneously with the stop_all_tasks function.","category":"page"},{"location":"scheduling/","page":"Scheduling","title":"Scheduling","text":"delay_in_s = 0.1 # delay between executions of the task in seconds\n\nfor i in 1:10\n    schedule(agent, PeriodicTaskData(delay_in_s)) do \n        # some expensive calculation\n        println(\"iterated\") \n    end\nend\n\nsleep(0.2)\nstop_all_tasks(agent)\nwait_for_all_tasks(agent)","category":"page"},{"location":"scheduling/","page":"Scheduling","title":"Scheduling","text":"Finally, stop_and_wait_for_all_tasks is a convenience methods combining both stop_all_tasks and wait_for_all_tasks.","category":"page"},{"location":"scheduling/#Scheduler","page":"Scheduling","title":"Scheduler","text":"","category":"section"},{"location":"scheduling/","page":"Scheduling","title":"Scheduling","text":"The Scheduler type is an internal structure that holds a collection of tasks to be scheduled and executed. Every agent contains such a scheduler struct by default and implements methods for convenient delegation.","category":"page"},{"location":"scheduling/","page":"Scheduling","title":"Scheduling","text":"struct Scheduler\n    tasks::Vector{Task}\nend","category":"page"},{"location":"scheduling/","page":"Scheduling","title":"Scheduling","text":"The execute_task function executes a task with a specific TaskData.","category":"page"},{"location":"scheduling/","page":"Scheduling","title":"Scheduling","text":"execute_task(f::Function, data::PeriodicTaskData)\nexecute_task(f::Function, data::InstantTaskData)\nexecute_task(f::Function, data::DateTimeTaskData)\nexecute_task(f::Function, data::AwaitableTaskData)\nexecute_task(f::Function, data::ConditionalTaskData)","category":"page"},{"location":"scheduling/","page":"Scheduling","title":"Scheduling","text":"The schedule function adds a task to the scheduler with the specified TaskData and scheduling type.","category":"page"},{"location":"scheduling/","page":"Scheduling","title":"Scheduling","text":"schedule(f::Function, scheduler::Union{Scheduler,Agent}, data::TaskData, scheduling_type::SchedulingType=ASYNC)","category":"page"},{"location":"scheduling/","page":"Scheduling","title":"Scheduling","text":"The wait_for_all_tasks function waits for all the scheduled tasks in the provided scheduler to complete.","category":"page"},{"location":"scheduling/","page":"Scheduling","title":"Scheduling","text":"wait_for_all_tasks(scheduler::Scheduler)","category":"page"},{"location":"scheduling/","page":"Scheduling","title":"Scheduling","text":"The stop_task function sends the stop signal to a task t. This will result in its completion once the next execution cycle is finished. If t is not stopable this will output a warning.","category":"page"},{"location":"scheduling/","page":"Scheduling","title":"Scheduling","text":"stop_task(scheduler::Scheduler, t::Task)","category":"page"},{"location":"scheduling/","page":"Scheduling","title":"Scheduling","text":"The stop_all_tasks function sends the stop signal to all stopable tasks. This will result in their completion once the next execution cycle is finished.","category":"page"},{"location":"scheduling/","page":"Scheduling","title":"Scheduling","text":"stop_all_tasks(scheduler::Scheduler)","category":"page"},{"location":"scheduling/","page":"Scheduling","title":"Scheduling","text":"The stop_and_wait_for_all_tasks function sends the stop signal to all stopable tasks. It then waits for all scheduled tasks to finish.","category":"page"},{"location":"scheduling/","page":"Scheduling","title":"Scheduling","text":"stop_and_wait_for_all_tasks(scheduler::Scheduler)","category":"page"},{"location":"encode_decode/#Mango.jl-Encoding-and-Decoding-(codec)-Feature-User-Documentation","page":"Codecs","title":"Mango.jl Encoding and Decoding (codec) Feature User Documentation","text":"","category":"section"},{"location":"encode_decode/","page":"Codecs","title":"Codecs","text":"Codecs provide functions for serializing and deserializing data to Mango containers. They use LightBSON.jl as their backend.","category":"page"},{"location":"encode_decode/","page":"Codecs","title":"Codecs","text":"As of now, the encode and decode functions forward their inputs directly to bson_read and bson_write. For most cases, we expect to pass messages as OrderedDict{String, Any}. We also forward an optional type field when decoding that is passed to bson_write to make use of the existing type-casting functionality here. For full information on what will work with this type of inference, we refer to the LightBSON.jl documentation.","category":"page"},{"location":"encode_decode/","page":"Codecs","title":"Codecs","text":"For future versions, we plan on adding a more convenient (but likely slower) type inference variant of the codec that saves necessary type information when encoding and iterates the output data while decoding to restore it exactly as it was before encoding (including type information).","category":"page"},{"location":"agent/#Agents","page":"Agents","title":"Agents","text":"","category":"section"},{"location":"agent/","page":"Agents","title":"Agents","text":"Agents are autonomous entities that can perceive their environment, make decisions, and interact with other agents and the system they inhabit. They are the building blocks of Mango.jl, representing the individual entities or actors within a larger system.","category":"page"},{"location":"agent/#Agent-Definition-with-@agent-Macro","page":"Agents","title":"Agent Definition with @agent Macro","text":"","category":"section"},{"location":"agent/","page":"Agents","title":"Agents","text":"To define an agent the @agent macro can be used. It simplifies the process of defining an agent struct and automatically adds necessary baseline fields. Here's how you can define an agent:","category":"page"},{"location":"agent/","page":"Agents","title":"Agents","text":"using Mango \n\n# Define your agent struct using @agent macro\n@agent struct MyAgent\n    my_own_field::String\nend\n\n# Create an instance of the agent\nmy_agent = MyAgent(\"MyValue\")","category":"page"},{"location":"agent/","page":"Agents","title":"Agents","text":"The @agent macro adds some internal baseline fields to the struct. You can initialize the agent with exclusive fields like my_own_field in the example.","category":"page"},{"location":"agent/#Role-Management","page":"Agents","title":"Role Management","text":"","category":"section"},{"location":"agent/","page":"Agents","title":"Agents","text":"Agents can have multiple roles associated with them. Roles can be added using the add function, allowing the agent to interact with its environment based on different roles. Here's how you can add roles to an agent:","category":"page"},{"location":"agent/","page":"Agents","title":"Agents","text":"using Mango\n\n# Define your role struct using @role macro\n@role struct MyRole\n    my_own_field::String\nend\n\n# Assume you have already defined roles using Mango.AgentRole module\nrole1 = MyRole(\"Role1\")\nrole2 = MyRole(\"Role2\")\n\n# Define your agent struct using @agent macro\n@agent struct MyContainerAgent end\n\n# Create an instance of the agent\nmy_agent = MyContainerAgent()\n\n# Add roles to the agent\nadd(my_agent, role1)\nadd(my_agent, role2)\n\n# Now you can interact with the roles as neededs","category":"page"},{"location":"agent/","page":"Agents","title":"Agents","text":"As this can be clunky at some time, there is the possibility to create an agent using only roles and add it to the container using add_agent_composed_of or without a container agent_composed_of.","category":"page"},{"location":"agent/","page":"Agents","title":"Agents","text":"using Mango\n\nc = create_tcp_container()\n\n@role struct RoleA end\n@role struct RoleB end\n@role struct RoleC end\n\n# internally an empty agent definition is used, the roles are added and the agent\n# is added to the given container\ncreated_agent = add_agent_composed_of(c, RoleA(), RoleB(), RoleC())","category":"page"},{"location":"agent/","page":"Agents","title":"Agents","text":"For more information on roles, take a look at Role definition","category":"page"},{"location":"agent/#Message-Handling","page":"Agents","title":"Message Handling","text":"","category":"section"},{"location":"agent/","page":"Agents","title":"Agents","text":"Agents and Roles can handle incoming messages through the handle_message function. By default, it does nothing, but you can override it to define message-specific behavior. You can also add custom message handlers for specific roles using the subscribe_message function. Here's how to handle messages:","category":"page"},{"location":"agent/","page":"Agents","title":"Agents","text":"using Mango\n\n@agent struct MySecondContainerAgent end\n@role struct MyHandlingRole end\n\n# Override the default handle_message function for custom behavior\nfunction Mango.handle_message(agent::MySecondContainerAgent, message::Any, meta::Any)\n    println(\"Received message @agent: \", message)\nend\n# Override the default handle_message function for custom behavior\nfunction Mango.handle_message(role::MyHandlingRole, message::Any, meta::Any)\n    println(\"Received message @role: \", message)\nend\n\n# Use the express API to show the effect\nrun_with_tcp(1, agent_composed_of(MyHandlingRole(), base_agent=MySecondContainerAgent())) do cl\n    wait(send_message(cl[1], \"Message\", address(cl[1][1])))\n    sleep(0.1)\nend","category":"page"},{"location":"agent/","page":"Agents","title":"Agents","text":"Besides the ability to handle messages, there also must be a possibility to send messages. This is implemented using the send_message function, defined on roles and agents.","category":"page"},{"location":"agent/","page":"Agents","title":"Agents","text":"using Mango\n\n# Define your agent struct using @agent macro\n@agent struct MySendingAgent\n    my_own_field::String\nend\n@role struct MySendingRole\n    my_own_field::String\nend\n\nagent = MySendingAgent(\"\")\nrole = MySendingRole(\"\")\n\nrun_with_tcp(1, agent_composed_of(role, base_agent=agent), PrintingAgent()) do cl\n    wait(send_message(agent, \"Message\", address(cl[1][2])))\n    wait(send_message(role, \"Message\", address(cl[1][2])))\n    sleep(0.1)\nend","category":"page"},{"location":"agent/","page":"Agents","title":"Agents","text":"Further, there are several specialized methods for sending messages, (1) send_tracked_message, (2) send_and_handle_answer, (3) reply_to, (4) forward_to.","category":"page"},{"location":"agent/","page":"Agents","title":"Agents","text":"(1) This function can be used to send a message with an automatically generated tracking id (uuid1) and it also accepts a response handler, which will     automatically be called when a response arrives to the tracked message (care to include the tracking id when responding or just use reply_to). (2) Variant of (1) which requires a response handler and enables the usage of the do syntax (see following code snippet). (3) Convenience function to respond to a received message without the need to create the AgentAddress by yourself. (4) Convenience function to forward messages to another agent. This function will set the approriate fields in the meta container to identify that a message has been forwarded and from which address it has been forwarded.","category":"page"},{"location":"agent/","page":"Agents","title":"Agents","text":"using Mango \n\n@agent struct MyMessageAgent end\n@agent struct ReplyAgent end\n\nagent1 = MyMessageAgent()\nagent2 = PrintingAgent() # defined in Mango\nagent3 = ReplyAgent()\n\nfunction Mango.handle_message(agent::ReplyAgent, message::Any, meta::Any)\n    # agent 3\n    reply_to(agent, \"Hello Agent, this is a response\", meta) # (3)\n\n    @info \"Reply\"\nend\nfunction handle_response(agent::MyMessageAgent, message::Any, meta::Any)\n    # agent 1\n    forward_to(agent, \"Forwarded message\", address(agent2), meta) # (4)\n\n    @info \"Handled response and forwarded the message\" message\nend\n\nrun_with_tcp(1, agent1, agent2, agent3) do cl\n    wait(send_tracked_message(agent1, \"Hello Agent, this is a tracked message\", address(agent3); response_handler=handle_response)) # (1)\n    wait(send_and_handle_answer(agent2, \"Hello Agent, this is a different tracked message\", address(agent3)) do agent, message, meta # (2)\n        @info \"Got an answer!\"\n    end)\n    sleep(0.1)\nend","category":"page"},{"location":"agent/","page":"Agents","title":"Agents","text":"There is also a possibility to enable automatic forwarding with adding so-called forwarding rules. For this you can use the function add_forwarding_rule. To delete these rules the function delete_forwarding_rule exists.","category":"page"},{"location":"agent/#Task-Scheduling","page":"Agents","title":"Task Scheduling","text":"","category":"section"},{"location":"agent/","page":"Agents","title":"Agents","text":"Agents can schedule tasks using the schedule function, which delegates to the Mango.schedule function. You can wait for all scheduled tasks to be completed using wait_for_all_tasks. Here's how to schedule tasks:","category":"page"},{"location":"agent/","page":"Agents","title":"Agents","text":"using Mango\n\n# Define your agent struct using @agent macro\n@agent struct MyTaskAgent\n    my_own_field::String\nend\nfunction my_task_function()\n    @info \"Task completed\"\nend\n\n# Create an instance of the agent\nmy_agent = MyTaskAgent(\"MyValue\")\n\n# Schedule a task for the agent\nwait(schedule(my_task_function, my_agent, InstantTaskData()))","category":"page"},{"location":"legals/#Legals","page":"Legals","title":"Legals","text":"","category":"section"},{"location":"legals/","page":"Legals","title":"Legals","text":"Address","category":"page"},{"location":"legals/","page":"Legals","title":"Legals","text":"OFFIS e. V.   Escherweg 2   26121 Oldenburg   Germany   Phone +49 441 9722-0   Fax +49 441 9722-102   Email: institut [ A T ] offis.de   Internet: www.offis.de  ","category":"page"},{"location":"legals/","page":"Legals","title":"Legals","text":"Board Members","category":"page"},{"location":"legals/","page":"Legals","title":"Legals","text":"Prof. Dr. Sebastian Lehnhoff (Chairman)   Prof. Dr. techn. Susanne Boll-Westermann   Prof. Dr.-Ing. Andreas Hein   Prof. Dr.-Ing. Astrid Nieße","category":"page"},{"location":"legals/","page":"Legals","title":"Legals","text":"Register Court","category":"page"},{"location":"legals/","page":"Legals","title":"Legals","text":"Amtsgericht Oldenburg   Registernumber VR 1956","category":"page"},{"location":"legals/","page":"Legals","title":"Legals","text":"VAT Identification Number","category":"page"},{"location":"legals/","page":"Legals","title":"Legals","text":"DE 811582102","category":"page"},{"location":"legals/","page":"Legals","title":"Legals","text":"Responsible in the sense of press law","category":"page"},{"location":"legals/","page":"Legals","title":"Legals","text":"Dr. Ing. Jürgen Meister (Director)   OFFIS e.V.   Escherweg 2   26121 Oldenburg  ","category":"page"},{"location":"legals/","page":"Legals","title":"Legals","text":"Disclaimer","category":"page"},{"location":"legals/","page":"Legals","title":"Legals","text":"Despite careful control OFFIS assumes no liability for the content of external links. The operators of such a website are solely responsible for its content. At the time of linking the concerned sites were checked for possible violations of law. Illegal contents were not identifiable at that time. A permanent control of the linked pages is not reasonable without specific indications of a violation. Upon notification of violations, OFFIS will remove such links immediately.","category":"page"},{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#Express","page":"API","title":"Express","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"This part contains basic convenience functions for creating and running Mango.jl simulations. ","category":"page"},{"location":"api/","page":"API","title":"API","text":"Modules = [Mango]\nPrivate = false\nPages = [\"express/api.jl\"]","category":"page"},{"location":"api/#Mango.PrintingAgent","page":"API","title":"Mango.PrintingAgent","text":"Simple agent just printing every message to @info.\n\n\n\n\n\n","category":"type"},{"location":"api/#Mango.activate-Union{Tuple{T}, Tuple{Function, Vector{T}}} where T<:ContainerInterface","page":"API","title":"Mango.activate","text":"activate(runnable, container_list)\n\nActvate the container(s), which includes starting the containers and shutting them down after the runnable has been executed. \n\nIn most cases the runnable will execute code, which starts some process  (e.g. some distributed negotiation) in the system to define the objective of the agent system.\n\nGenerally this function is a convenience function and is equivalent to starting all containers  in the list, executing the code represented by runnable and shuting down the container again. Further, this function will handle errors occuring while running the runnable and ensure the containers are shutting down.\n\nExamples\n\nactivate(your_containers) do \n   # Send the first message to start the system\n   send_message(defined_agent, \"Starting somethin\", address(other_defined_agent))\n\n   # wait some time\n   wait(some_stopping_condition)\nend\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.add_agent_composed_of-Tuple{ContainerInterface, Vararg{Role}}","page":"API","title":"Mango.add_agent_composed_of","text":"add_agent_composed_of(container, roles::Role...; suggested_aid::Union{Nothing,String}=nothing, base_agent::Union{Nothing,Agent}=nothing)\n\nCreate an agent which is composed of the given roles roles... and register the agent  to the container. \n\nIf no base_agent is provided the agent struct used is an empty struct, which is  only used as a container for the roles. The agent will be returned by the function.\n\nExamples\n\nagent = add_agent_composed_of(your_container, RoleA(), RoleB(), RoleC())\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.agent_composed_of-Tuple{Vararg{Role}}","page":"API","title":"Mango.agent_composed_of","text":"agent_composed_of(roles::Role...; base_agent::Union{Nothing,Agent}=nothing)\n\nCreate an agent which is composed of the given roles roles....\n\nIf no base_agent is provided the agent struct used is an empty struct, which is  only used as a container for the roles. The agent will be returned by the function.\n\nExamples\n\nagent = agent_composed_of(RoleA(), RoleB(), RoleC())\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.create_mqtt_container","page":"API","title":"Mango.create_mqtt_container","text":"create_mqtt_container(host, port, client_id; codec=nothing)\n\nCreate a container using an MQTT protocol. \n\nThe host is expected to be the IP-adress of the broker, port is the port of the broker,  the client_id is the id of the client which will be created and connected to the broker.  Optionally you can also provide a codec as tuple of functions (first encode, second decode, see  encode and decode).\n\nExamples\n\nagent = create_mqtt_container(\"127.0.0.1\", 5555, \"MyClient\")\n\n\n\n\n\n","category":"function"},{"location":"api/#Mango.create_tcp_container","page":"API","title":"Mango.create_tcp_container","text":"create_tcp_container(host, port; codec=nothing)\n\nCreate a container using an TCP protocol. \n\nThe host is expected to be the IP-adress to bind on, port is the port to bind on. Optionally you  can also provide a codec as tuple of functions (first encode, second decode, see  encode and decode).\n\nExamples\n\nagent = create_mqtt_container(\"127.0.0.1\", 5555, \"MyClient\")\n\n\n\n\n\n","category":"function"},{"location":"api/#Mango.run_in_real_time-Tuple{Function, Int64, Function, Vararg{Agent}}","page":"API","title":"Mango.run_in_real_time","text":"run_in_real_time(runnable::Function,\nn_container::Int,\ncontainer_list_creator::Function,\nagents::Agent...)\n\nLet the agents run in containers (real time).\n\nDistributes the given agents contained in the agenttuple to `ncontainer(real time container) and execute therunnable`  (takes the container list as argument) while the container are active to run. \n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.run_in_real_time-Tuple{Function, Int64, Function, Vararg{Tuple}}","page":"API","title":"Mango.run_in_real_time","text":"run_in_real_time(runnable::Function,\nn_container::Int,\ncontainer_list_creator::Function,\nagent_tuple::Tuple...)\n\nLet the agents run in containers (real time).\n\nDistributes the given agents contained in the agent_tuple to n_container (real time container) and execute the runnable  (takes the container list as argument) while the container are active to run. It is possible to  add supplementary information per agent as Tuple. For example (Agent, :aid => \"my_aid\"). The type of the containers are determined by the container_list_creator (ncontainer as argument, has to return a list of container with ncontainer entries).\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.run_in_simulation-Tuple{Function, Int64, Vararg{Agent}}","page":"API","title":"Mango.run_in_simulation","text":"run_in_simulation(runnable::Function, agents::Agent, n_steps::Int; start_time::DateTime=DateTime(2000, 1, 1), step_size_s::Int=DISCRETE_EVENT)\n\nLet the agents run as simulation in a simulation container.\n\nExecute the runnable in SimulationContainer while the container is active to run. After the runnable the simulation container is stepped n_steps time with a step_size_s (default is discrete event). The start time can be specified using start_time.\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.run_with_mqtt-Tuple{Function, Int64, Vararg{Agent}}","page":"API","title":"Mango.run_with_mqtt","text":"run_with_mqtt(runnable::Function,\nn_container::Int,\nagents::Agent...;\nbroker_host::String=\"127.0.0.1\",\nbroker_port::Int=1883,\ncodec::Union{Nothing,Tuple{Function,Function}}=(encode, decode))\n\nLet the agents run in mqtt containers (real time).\n\nDistributes the given agents to n_container (real time container) and execute the runnable  (takes the container list as argument) while the container are active to run.  Here, MQTT container are created with the broker on broker_host and at the port broker_port. The containers are assignede client ids (client1 client2 ...)  \n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.run_with_mqtt-Tuple{Function, Int64, Vararg{Tuple}}","page":"API","title":"Mango.run_with_mqtt","text":"run_with_mqtt(runnable::Function,\nn_container::Int,\nagent_tuples::Tuple...;\nbroker_host::String=\"127.0.0.1\",\nbroker_port::Int=1883,\ncodec::Union{Nothing,Tuple{Function,Function}}=(encode, decode))\n\nLet the agents run in mqtt containers (real time).\n\nDistributes the given agents to n_container (real time container) and execute the runnable  (takes the container list as argument) while the container are active to run.  It is possible to  add supplementary information per agent as Tuple. For example (Agent, :aid => \"my_aid\", :topics => [\"topic\"]). Here, MQTT container are created with the broker on broker_host and at the port broker_port. The containers are assignede client ids (client1 client2 ...)  \n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.run_with_tcp-Tuple{Function, Int64, Vararg{Agent}}","page":"API","title":"Mango.run_with_tcp","text":"run_with_tcp(runnable::Function,\nn_container::Int,\nagents::Agent...;\nhost::String=\"127.0.0.1\",\nstart_port::Int=5555,\ncodec::Union{Nothing,Tuple{Function,Function}}=(encode, decode))\n\nLet the agents run in tcp containers (real time).\n\nDistributes the given agents to n_container (real time container) and execute the runnable  (takes the container list as argument) while the container are active to run. Here, TCP container are created on host starting with the port start_port.\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.run_with_tcp-Tuple{Function, Int64, Vararg{Tuple}}","page":"API","title":"Mango.run_with_tcp","text":"run_with_tcp(runnable::Function,\nn_container::Int,\nagent_tuples::Union{Tuple,Agent}...;\nhost::String=\"127.0.0.1\",\nstart_port::Int=5555,\ncodec::Union{Nothing,Tuple{Function,Function}}=(encode, decode))\n\nLet the agents run in tcp containers (real time).\n\nDistributes the given agent_tuples to n_container (real time container) and execute the runnable  (takes the container list as argument) while the container are active to run. It is possible to  add supplementary information per agent as Tuple. For example (Agent, :aid => \"my_aid\"). Here, TCP container are created on host starting with the port start_port.\n\n\n\n\n\n","category":"method"},{"location":"api/#Agent-and-Roles","page":"API","title":"Agent and Roles","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Here, the API for the agent structs created with @agent/@role is listed. ","category":"page"},{"location":"api/","page":"API","title":"API","text":"Modules = [Mango]\nPrivate = false\nPages = [\"agent/api.jl\", \"agent/core.jl\", \"agent/role.jl\"]\nOrder = [:macro, :function, :constant, :type, :module]","category":"page"},{"location":"api/#Mango.address-Tuple{Mango.AgentInterface}","page":"API","title":"Mango.address","text":"address(agent)\n\nReturn the agent address of the agent as AgentAddress or MQTTAddress depending on the protocol.\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.aid-Tuple{Mango.AgentInterface}","page":"API","title":"Mango.aid","text":"aid(agent)\n\nReturn the aid of the agent.\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.forward_to-Tuple{Mango.AgentInterface, Any, Address, AbstractDict}","page":"API","title":"Mango.forward_to","text":"forward_to(agent, content, forward_to_address, received_meta; kwargs...)\n\nForward the message to a specific agent using the metadata received on handling the message. This method essentially simply calls send_message on the input given, but also adds and fills the correct metadata fields to mark the message as forwarded. \n\nFor this the following meta data is set.\n\n'forwarded=true',\n'forwardedfromaddress=address of the original sender',\n'forwardedfromid=id of the original sender'\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.reply_to-Tuple{Mango.AgentInterface, Any, AbstractDict}","page":"API","title":"Mango.reply_to","text":"reply_to(\nagent::AgentInterface,\ncontent::Any,\nreceived_meta::AbstractDict,\n\n)\n\nConvenience method to reply to a received message using the meta the agent received. This reduces the regular send_message as response send_message(agent, \"Pong\", AgentAddress(aid=meta[\"sender_id\"], address=meta[\"sender_addr\"])) to reply_to(agent, \"Pong\", meta)\n\nFurthermore it guarantees that agent address (including the tracking id, which is part of the address!) is correctly passed to the mango container.\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.send_and_handle_answer-Tuple{Function, Mango.AgentInterface, Any, Address}","page":"API","title":"Mango.send_and_handle_answer","text":"send_and_handle_answer(\nresponse_handler::Function,\nagent::AgentInterface,\ncontent::Any,\nagent_address::Address;\ncalling_object::Any=nothing,\nkwargs...)\n\nConvenience method for sending tracked messages with response handler to the answer.\n\nSends a tracked message with a required response_handler to enable to use the syntax\n\nsend_and_handle_answer(...) do agent, message, meta\n\t# handle the answer\nend\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.send_message-Tuple{Mango.AgentInterface, Any, Address}","page":"API","title":"Mango.send_message","text":"send_message(\nagent::AgentInterface,\ncontent::Any,\nagent_address::Address;\nkwargs...,\n\n)\n\nSend a message with the content content to the agent represented by agent_address. \n\nThis method will always set a sender_id. Additionally, further keyword arguments can be defined to fill the  internal meta data of the message.\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.send_tracked_message-Tuple{Mango.AgentInterface, Any, Address}","page":"API","title":"Mango.send_tracked_message","text":"send_tracked_message(\nagent::AgentInterface,\ncontent::Any,\nagent_address::Address;\nresponse_handler::Function=(agent, message, meta) -> nothing,\ncalling_object::Any=nothing,\nkwargs...,\n\n)\n\nSend a message with the content content to the agent represented by agent_address. This function will set a generated tracking_id to the address, which allows the identification of the dialog. \n\nIt is possible to define a response_handler, to which a function can be assigned, which handles the answer  to this message call. Note that the resonding agent needs to use the same tracking id in the response, ideally reply_to is used to achieve this automatically. \n\nThis method will always set a sender_id. Additionally, further keyword arguments can be defines to fill the  internal meta data of the message.\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.Address","page":"API","title":"Mango.Address","text":"Supertype of all address types\n\n\n\n\n\n","category":"type"},{"location":"api/#Mango.Agent","page":"API","title":"Mango.Agent","text":"Base-type for all agents in mango. Generally exists for type-safety and default implementations across all agents.\n\n\n\n\n\n","category":"type"},{"location":"api/#Mango.@agent-Tuple{Any}","page":"API","title":"Mango.@agent","text":"Macro for defining an agent struct. Expects a struct definition as argument.\n\nThe macro does 3 things:\n\nIt adds all baseline fields, defined in AGENT_BASELINE_FIELDS (the agent context context, the role handler role_handler, and the aid)\nIt adds the supertype Agent to the given struct.\nIt applies @with_def for default construction, the baseline fields are assigned to default values\n\nExample\n\nFor example the usage could like this.\n\n@agent struct MyAgent\n\tmy_own_field::String\nend\n\n# results in\n\n@with_def mutable struct MyAgent <: Agent\n\t# baseline fields...\n\tmy_own_field::String\n    my_own_field_with_default::String = \"Default\"\nend\n\n# so you would construct your agent like this\n\nmy_agent = MyAgent(\"own value\", my_own_field_with_default=\"OtherValue\")\n\n\n\n\n\n","category":"macro"},{"location":"api/#Base.schedule-Tuple{Function, Agent, TaskData}","page":"API","title":"Base.schedule","text":"schedule(f::Function, agent::Agent, data::TaskData)\n\nDelegates to the scheduler Scheduler\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.add-Tuple{Agent, Role}","page":"API","title":"Mango.add","text":"add(agent::Agent, role::Role)\n\nAdd a role to the agent. This will add the role to the internal RoleHandler of the agent and it will bind the RoleContext to the role, which enables the role to interact with its environment.\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.add_forwarding_rule-Tuple{Agent, AgentAddress, AgentAddress, Bool}","page":"API","title":"Mango.add_forwarding_rule","text":"add_forwarding_rule(agent, from_addr::AgentAddress, to_address::AgentAddress, forward_replies::Bool)\n\nAdd a rule for message forwarding.\n\nAfter calling the agent will auto-forward every message coming from from_addr to to_address. If forwardreplies is set, all replies from `toaddressare forwarded back tofrom_addr`.\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.add_service!-Tuple{Agent, Any}","page":"API","title":"Mango.add_service!","text":"add_service!(agent, service)\n\nAdd a service to the agent. Every service can exists exactly one time (stored by type).\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.delete_forwarding_rule-Tuple{Agent, AgentAddress, Union{Nothing, AgentAddress}}","page":"API","title":"Mango.delete_forwarding_rule","text":"delete_forwarding_rule(agent, from_addr::AgentAddress, to_address::Union{Nothing,AgentAddress})\n\nDelete an added forwarding rule. If to_address is not set, all rules are removed matching from_addr. If it set, both addresses need to match.\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.handle_message-Tuple{Agent, Any, Any}","page":"API","title":"Mango.handle_message","text":"handle_message(agent::Agent, message::Any, meta::Any)\n\nDefines a function for an agent, which will be called when a message is dispatched to the agent. This methods will be called with any arriving message (according to the multiple dispatch of julia).\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.on_ready-Tuple{Agent}","page":"API","title":"Mango.on_ready","text":"on_ready(agent::Agent)\n\nLifecycle Hook-in function called when the agent system as a whole is ready, the  hook-in has to be manually activated using notify_ready(container::Container). If you use     the activate function, it is called automatically.\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.on_start-Tuple{Agent}","page":"API","title":"Mango.on_start","text":"on_start(agent::Agent)\n\nLifecycle Hook-in function called when the container of the agent has been started, depending on the container type it may not be called (if there is no start at all,  f.e. the simulation container)\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.roles-Tuple{Agent}","page":"API","title":"Mango.roles","text":"roles(agent)\n\nReturn all roles of the given agent\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.service_of_type-Union{Tuple{T}, Tuple{Agent, Type{T}}, Tuple{Agent, Type{T}, Union{Nothing, T}}} where T","page":"API","title":"Mango.service_of_type","text":"service_of_type(agent, type::Type{T}, default=nothing)::Union{T,Nothing} where {T}\n\nReturn the current agent service of the type type. \n\nIf a default is set, this default service will be added to the agent as service of te type `type. The function is especially useful if you want to extend the functionality of the agent without having to change the internals of the agent, as this functions enables the user to add  arbitrary data to the agent on which functions can be defined.\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.services-Tuple{Agent}","page":"API","title":"Mango.services","text":"services(agent)::Dict{DataType,Any}\n\nReturn a list of services, which were added to the agent.\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.shutdown-Tuple{Agent}","page":"API","title":"Mango.shutdown","text":"shutdown(agent)\n\nWill be called on shutdown of the container, in which the agent is living\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.stop_all_tasks-Tuple{Agent}","page":"API","title":"Mango.stop_all_tasks","text":"stop_all_tasks(agent::Agent)\n\nDelegates to the scheduler Scheduler\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.stop_and_wait_for_all_tasks-Tuple{Agent}","page":"API","title":"Mango.stop_and_wait_for_all_tasks","text":"stop_and_wait_for_all_tasks(agent::Agent)\n\nDelegates to the scheduler Scheduler\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.stop_task-Tuple{Agent, Task}","page":"API","title":"Mango.stop_task","text":"stop_task(agent::Agent, t::Task)\n\nDelegates to the scheduler Scheduler\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.wait_for_all_tasks-Tuple{Agent}","page":"API","title":"Mango.wait_for_all_tasks","text":"wait_for_all_tasks(agent::Agent)\n\nDelegates to the scheduler Scheduler\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.AgentContext","page":"API","title":"Mango.AgentContext","text":"Context of the agent. Represents the environment for the specific agent. Therefore it includes a  connection to the container, including all functions used for interacting with the environment for the agent.\n\n\n\n\n\n","category":"type"},{"location":"api/#Mango.AgentRoleHandler","page":"API","title":"Mango.AgentRoleHandler","text":"Internal data regarding the roles.\n\n\n\n\n\n","category":"type"},{"location":"api/#Mango.@role-Tuple{Any}","page":"API","title":"Mango.@role","text":"Macro for defining a role struct. Expects a struct definition as argument.\n\nThe macro does 3 things:\n\nIt adds all baseline fields, defined in ROLE_BASELINE_FIELDS (the role context)\nIt adds the supertype Role to the given struct.\nIt applies @with_def for default construction, the baseline fields are assigned to default values\n\nFor example the usage could like this.\n\n@role struct MyRole\n\tmy_own_field::String\nend\n\n# results in\n\n@with_def mutable struct MyRole <: Role\n\t# baseline fields...\n\tmy_own_field::String\n    my_own_field_with_default::String = \"Default\"\nend\n\n# so youl would construct your role like this\n\nmy_roel = MyRole(\"own value\", my_own_field_with_default=\"OtherValue\")\n\n\n\n\n\n","category":"macro"},{"location":"api/#Mango.@shared-Tuple{Any}","page":"API","title":"Mango.@shared","text":"Mark the field as shared across roles. \n\nThis only works on structs with empty default constructor. Internally the marked field will be initialized with a model created by get_model. The model will be set when the Role is added to an agent.\n\nExample\n\n@kwdef struct Model\n    field::Int = 0\nend\n@role struct MyRole\n    @shared\n    my_model::Model # per agent the exact same in every agent.\nend\n\n\n\n\n\n","category":"macro"},{"location":"api/#Mango.bind_context-Tuple{Role, RoleContext}","page":"API","title":"Mango.bind_context","text":"Internal function, used to initialize to role for a specified agent\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.emit_event-Tuple{Role, Any}","page":"API","title":"Mango.emit_event","text":"emit_event(role::Role, event::Any; event_type::Any=nothing)\n\nEmit an event to their subscriber.\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.get_model-Tuple{Role, DataType}","page":"API","title":"Mango.get_model","text":"get_model(role::Role, type::DataType)\n\nGet a shared model from the pool. If the model does not exist yet, it will be created. Only types with default constructor are allowed!\n\nExample\n\n@kwdef struct ExampleModel\n    my_field::Int = 0\nend\nrole = ExampleRole()\nmodel::ExampleModel = get_model(role, ExampleModel)\nmodel.my_field = 1\nmodel2::ExampleModel = get_model(role, ExampleModel)\n# model == model2, it will also be the same for every role!\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.handle_event-Tuple{Role, Role, Any}","page":"API","title":"Mango.handle_event","text":"handle_event(role::Role, src::Role, event::Any; event_type::Any)\n\nDefault function for arriving events, which get dispatched to the role.\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.handle_message-Tuple{Role, Any, Any}","page":"API","title":"Mango.handle_message","text":"Default function for arriving messages, which get dispatched to the role. This function will be called for every message arriving at the agent of the role.\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.setup-Tuple{Role}","page":"API","title":"Mango.setup","text":"setup(role::Role)\n\nHook-in function to setup the role, after it has been added to its agent.\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.subscribe_event","page":"API","title":"Mango.subscribe_event","text":"subscribe_event(role::Role, event_type::Any, event_handler::Any, condition::Function)\n\nSubscribe to specific types of events. \n\nThe types of events are determined by the condition function (accepting src and event) and  by the event_type.\n\nExample\n\nstruct MyEvent end\nfunction custom_handler(role::Role, src::Role, event::Any, event_type::Any)\n    # do your thing\nend\nsubscribe_event(my_role, MyEvent, custom_handler, (src, event) -> aid(src) == \"agent0\")\n\n\n\n\n\n","category":"function"},{"location":"api/#Mango.subscribe_message-Tuple{Role, Function, Function}","page":"API","title":"Mango.subscribe_message","text":"subscribe_message(role::Role, handler::Function, condition::Function)\n\nSubscribe a message handler function (it need to have the signature (role, message, meta)) to the message dispatching. This handler function will be called everytime the given condition function ((message, meta) -> boolean) evaluates to true when a message arrives at the roles agent.\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.subscribe_send-Tuple{Role, Function}","page":"API","title":"Mango.subscribe_send","text":"subscribe_send(role::Role, handler::Function)\n\nSubscribe a send_message hook in function (signature, (role, content, receiverid, receiveraddr; kwargs...)) to the message sending. The hook in function will be called every time a message is sent by the agent.\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.Role","page":"API","title":"Mango.Role","text":"Defines the type Role, which is the common base types for all roles in mango.\n\nA Role is a bundled behavivor of an agent, which shall fulfill exactly one  responsibility of an agent - the role. Technically speaking roles are the way to implement the composition pattern for agents, and to introduce modular archetypes, which shall be reused in different contexts. \n\n\n\n\n\n","category":"type"},{"location":"api/#Mango.RoleContext","page":"API","title":"Mango.RoleContext","text":"The RoleContext connects the role with its environment, which is mostly its agents. This is abstracted using the AgentInterface.\n\n\n\n\n\n","category":"type"},{"location":"api/#Real-time-container","page":"API","title":"Real time container","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"This part contains the API related to the container construction, access and management.","category":"page"},{"location":"api/","page":"API","title":"API","text":"Modules = [Mango]\nPrivate = false\nPages = [\"container/api.jl\", \"container/core.jl\", \"container/mqtt.jl\", \"container/protocol.jl\", \"container/tcp.jl\"]","category":"page"},{"location":"api/#Mango.SENDER_ADDR","page":"API","title":"Mango.SENDER_ADDR","text":"Key for the sender address in the meta dict\n\n\n\n\n\n","category":"constant"},{"location":"api/#Mango.SENDER_ID","page":"API","title":"Mango.SENDER_ID","text":"Key for the sender in the meta dict\n\n\n\n\n\n","category":"constant"},{"location":"api/#Mango.TRACKING_ID","page":"API","title":"Mango.TRACKING_ID","text":"Key for the tracking number used for dialogs in the meta dict\n\n\n\n\n\n","category":"constant"},{"location":"api/#Mango.AgentAddress","page":"API","title":"Mango.AgentAddress","text":"Default AgentAddress base type, where the agent identifier is based on the container created agent id (aid). Used with the TCP protocol.\n\n\n\n\n\n","category":"type"},{"location":"api/#Mango.ContainerInterface","page":"API","title":"Mango.ContainerInterface","text":"Supertype of every container implementation. This acts as an interface to be used by the agents in their contexts.\n\n\n\n\n\n","category":"type"},{"location":"api/#Mango.MQTTAddress","page":"API","title":"Mango.MQTTAddress","text":"Connection information for an MQTT topic on a given broker.  Used with the MQTT protocol. \n\n\n\n\n\n","category":"type"},{"location":"api/#Mango.agents-Tuple{ContainerInterface}","page":"API","title":"Mango.agents","text":"agents(container)\n\nReturn the agents of the container. The agents have a fixed order.\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.notify_ready-Tuple{ContainerInterface}","page":"API","title":"Mango.notify_ready","text":"notify_ready(container::Container)\n\nMark the agent system as ready.\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.protocol_addr-Tuple{ContainerInterface}","page":"API","title":"Mango.protocol_addr","text":"protocol_addr(container)\n\nReturn technical address of the container.\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.register","page":"API","title":"Mango.register","text":"register(\ncontainer,\nagent,\nsuggested_aid::Union{String,Nothing}=nothing;\nkwargs...,\n\n)\n\nRegister the agent to the container. Retun the agent itself for convenience.\n\nNormally the aid is generated, however it is possible to suggest an aid, which will be used if it has not been used yet and if it is not conflicting with the default naming pattern (agent0, agent1, ...)\n\n\n\n\n\n","category":"function"},{"location":"api/#Mango.send_message","page":"API","title":"Mango.send_message","text":"send_message(\ncontainer::ContainerInterface,\ncontent::Any,\naddress::Address,\nsender_id::Union{Nothing,String}=nothing;\nkwargs...,\n\n)\n\nSend a message message using the given container container to the given address. Additionally, further keyword arguments can be defines to fill the internal meta data of the message.\n\n\n\n\n\n","category":"function"},{"location":"api/#Mango.shutdown-Tuple{ContainerInterface}","page":"API","title":"Mango.shutdown","text":"shutdown(container)\n\nShutdown the container. Here all loops are closed, resources freed. It is recommended to use activate  instead of shutting down manually.\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.start-Tuple{ContainerInterface}","page":"API","title":"Mango.start","text":"start(container)\n\nStart the container. It is recommended to use activate instead of starting manually.\n\nWhat exactly happend highly depends on the protocol and the container implmentation. For example, for TCP the container binds on IP and port, and the listening loop started.\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.Container","page":"API","title":"Mango.Container","text":"The default container struct, representing the container as actor. The container is implemented by composition. This means the container consists of different implementations of base types, which define the behavior of the container itself. That being said, the same container generally able to send messages via different protocols using different codecs.\n\n\n\n\n\n","category":"type"},{"location":"api/#Mango.send_message-Tuple{Container, Any, MQTTAddress, Vararg{Any}}","page":"API","title":"Mango.send_message","text":"send_message(\ncontainer::Container,\ncontent::Any,\nmqtt_address::MQTTAddress,\nkwargs...,\n\n)\n\nSend message version for MQTT topics.  Note that there is no local message forwarding here because messages always get pushed to a broker and are not directly addressed to an agennt.\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.MQTTProtocol","page":"API","title":"Mango.MQTTProtocol","text":"Protocol that abstracts a Mosquitto.jl client for Mango agents.\n\nCreation\n\nMQTTProtocol(client_id::String, broker_addr::InetAddr)\n\nCreate an MQTT client that connects to the broker at broker_addr with a client_id.\n\nFields\n\nclient - Mosquitto.jl client\nbroker_addr - address of the MQTT broker to connect to\nconnected - internal flag indicating connection status\nactive - internal flag indicating listen loop activity\nmsg_channel - message channel of the MQTT client\nconn_channel - connection channel of the MQTT client\ntopictoaid - internal dictionary to track which registered agent is subscribed to which topic\n\n\n\n\n\n","category":"type"},{"location":"api/#Base.close-Tuple{MQTTProtocol}","page":"API","title":"Base.close","text":"close(protocol::MQTTProtocol)\n\nDisconnect the client from the broker and stop the message loop.\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.id-Tuple{MQTTProtocol}","page":"API","title":"Mango.id","text":"id(protocol::MQTTProtocol)\n\nReturn the name the client is registered with at its broker.\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.init-Tuple{MQTTProtocol, Function, Function}","page":"API","title":"Mango.init","text":"init(protocol::MQTTProtocol, stop_check::Function, data_handler::Function)\n\nInitialize the Mosquitto looping task for the provided protocol and forward incoming messages to data_handler. \n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.notify_register-Tuple{MQTTProtocol, String}","page":"API","title":"Mango.notify_register","text":"notify_register(protocol::MQTTProtocol, aid::String; kwargs...)\n\nNotify the protocol MQTT client that a new agent with aid has been registered. \n\nRegistration expects a kwarg topics to subscribe the agent to.  If any topic is not yet subscribed by the client subscribe is called for it.\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.parse_id-Tuple{MQTTProtocol, Any}","page":"API","title":"Mango.parse_id","text":"parse_id(_::MQTTProtocol, id::Any)::String\n\nReturn the id of the protocol as string (for compliance with container core).\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.send-Tuple{MQTTProtocol, String, Any}","page":"API","title":"Mango.send","text":"send(protocol::MQTTProtocol, destination::String, message::Any)\n\nSend a message to topic destination on the clients MQTT broker. \n\nReturns\n\nReturn value and message id from MQTT library.\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.subscribe-Tuple{MQTTProtocol, String}","page":"API","title":"Mango.subscribe","text":"subscribe(protocol::MQTTProtocol, topic::String; qos::Int=1)\n\nSubscribe the MQTT client of the protocol to topic with the given qos setting.\n\nReturns\n\nThe Mosquitto error code and the message id.\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.Protocol","page":"API","title":"Mango.Protocol","text":"Type for all implementations of protocols, acts like an interface. A protocol defines the way message are processed and especially sent and received  to an other peer. F.E. A protocol could be to send messages using a plain TCP connection, which would indicate that an internet address (host + port) is required for the communication.\n\nThe parameterized type T indicates type, which defines the address data of the receiver and sender.\n\nEvery protocol has to define two methods.\n\nsend: defines the behavior of the protocol when an agents sends a messages\ninit: defines the necessary steps to initialize (especially) the receiver loop and\n\n\t therefore accepts a stop check and a data handler function to indicate when the receiver should stop, \n\t respectively how to dispatch the received message to the correct agent\n\n\n\n\n\n","category":"type"},{"location":"api/#Mango.id-Union{Tuple{Protocol{T}}, Tuple{T}} where T","page":"API","title":"Mango.id","text":"id(protocol::Protocol{T}) where {T}\n\nReturn the external identifier associated with the protocol (e.g. it could be the host+port, dns name, ...)\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.init-Union{Tuple{T}, Tuple{Protocol{T}, Function, Function}} where T","page":"API","title":"Mango.init","text":"init(protocol::Protocol{T}, stop_check::Function, data_handler::Function) where {T}\n\nInitialized the protocols internal loops (if exists). In most implementation this would mean that the receiver loop is started. To handle received messages the data_handler function can be passed (msg, sender) -> your handling code. \n\nTo control the lifetime of the loops a stop_check should be passed (() -> boolean). If the stop check is true the loops will  terminate. The exact behavior depends on the implementation though.\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.notify_register-Union{Tuple{T}, Tuple{Protocol{T}, String}} where T","page":"API","title":"Mango.notify_register","text":"notify_register(protocol::Protocol{T}, aid::String; kwargs...) where {T}\n\nProtocol specific updates called when a new agent is registered.\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.parse_id-Union{Tuple{T}, Tuple{Protocol{T}, Any}} where T","page":"API","title":"Mango.parse_id","text":"parse_id(protocol::Protocol{T}, id_data::Any)::T where {T}\n\nParse different types to the correct type (if required). Should be implemented if the id type is not trivial.\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.send-Union{Tuple{T}, Tuple{Protocol{T}, T, Any}} where T","page":"API","title":"Mango.send","text":"send(protocol::Protocol{T}, destination::T, message::Any) where {T}\n\nSend the message message to the agent known by the adress destination. How the message is exactly handled is  determined by the protocol invoked. \n\nThe type of the destination has to match with the protocol. The function returns a boolean indicating  whether the message was successfull sent\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.TCPProtocol","page":"API","title":"Mango.TCPProtocol","text":"Defines the tcp protocol. It holds a binding to an IP+Port and a tcp connection pool.\n\n\n\n\n\n","category":"type"},{"location":"api/#Base.close-Tuple{Mango.TCPConnectionPool}","page":"API","title":"Base.close","text":"close(pool::TCPConnectionPool)\n\nClose the pool. This closes all connections. Further, this function will wait until all connection are released.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.close-Tuple{TCPProtocol}","page":"API","title":"Base.close","text":"close(protocol::TCPProtocol)\n\nRelease all tcp resources (binding on port and connections in the pool).\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.acquire_tcp_connection-Tuple{Mango.TCPConnectionPool, Sockets.InetAddr}","page":"API","title":"Mango.acquire_tcp_connection","text":"acquire_tcp_connection(tcp_pool::TCPConnectionPool, key::InetAddr)::Union{TCPSocket,Nothing}\n\nAcquire a tcp connection from the pool for the key (IP+Port). Return a TCPSocket if the pool is not closed yet, otherwise nothing will be returned\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.id-Tuple{TCPProtocol}","page":"API","title":"Mango.id","text":"id(protocol::TCPProtocol)\n\nReturn the technical address of the protocol (ip + port)\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.init-Tuple{TCPProtocol, Function, Function}","page":"API","title":"Mango.init","text":"init(protocol::TCPProtocol, stop_check::Function, data_handler::Function)\n\nInitialized the tcp protocol. This starts the receiver and stop loop. The receiver loop will call the data_handler with every incoming message. Further it provides as sender adress a InetAddr object. \n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.parse_id-Tuple{TCPProtocol, Any}","page":"API","title":"Mango.parse_id","text":"parse_id(_::TCPProtocol, id::Any)::InetAddr\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.release_tcp_connection-Tuple{Mango.TCPConnectionPool, Sockets.InetAddr, Sockets.TCPSocket}","page":"API","title":"Mango.release_tcp_connection","text":"release_tcp_connection(\ntcp_pool::TCPConnectionPool,\nkey::InetAddr,\nconnection::TCPSocket,\n\n)\n\nRelease the given tcp connection indexed by the key. This will put the connection back to the pool.\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.send-Tuple{TCPProtocol, Sockets.InetAddr, Vector{UInt8}}","page":"API","title":"Mango.send","text":"send(protocol::TCPProtocol, destination::InetAddr, message::Vector{UInt8})\n\nSend a message message over plain TCP using destination as destination address. The message has to be provided  as a form, which is writeable to an arbitrary IO-Stream.\n\nReturn true if successfull.\n\n\n\n\n\n","category":"method"},{"location":"api/#Simulation","page":"API","title":"Simulation","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"In the following the APIs regarding the simulation container are listed.","category":"page"},{"location":"api/","page":"API","title":"API","text":"Modules = [Mango]\nPrivate = false\nPages = [\"container/simulation.jl\", \"simulation/communication.jl\", \"simulation/tasks.jl\"]","category":"page"},{"location":"api/#Mango.SimulationContainer","page":"API","title":"Mango.SimulationContainer","text":"The SimulationContainer used as a base struct to enable simulations in Mango.jl. Shall be created using create_simulation_container.\n\n\n\n\n\n","category":"type"},{"location":"api/#Mango.SimulationResult","page":"API","title":"Mango.SimulationResult","text":"Result of one simulation step.\n\n\n\n\n\n","category":"type"},{"location":"api/#Mango.TaskSimulationResult","page":"API","title":"Mango.TaskSimulationResult","text":"Result of all task simulation iterations.\n\n\n\n\n\n","category":"type"},{"location":"api/#Mango.create_simulation_container-Tuple{Dates.DateTime}","page":"API","title":"Mango.create_simulation_container","text":"create_simulation_container(start_time::DateTime; communication_sim::Union{Nothing,CommunicationSimulation}=nothing, task_sim::Union{Nothing,TaskSimulation}=nothing)\n\nCreate a simulation container. The container is intitialized with start_time. \n\nPer default the SimpleCommunicationSimulation is used for communication simulation, and SimpleTaskSimulation for simulating the tasks of agents. To replace these, communication_sim and respectively task_sim can be set.\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.on_step-Tuple{Agent, World, Clock, Real}","page":"API","title":"Mango.on_step","text":"on_step(agent::Agent, world::World, clock::Clock, step_size_s::Real)\n\nHook-in, called on every step of the simulation container for every agent.\n\nFurther, the world is passed, which represents a common view on the environment in which agents can interact with eachother. Besides, the clock and the step_size_s can be used to read the current simulation time and the time which passes in the current step.\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.step_simulation","page":"API","title":"Mango.step_simulation","text":"step_simulation(container::SimulationContainer, step_size_s::Real=DISCRETE_EVENT)::Union{SimulationResult,Nothing}\n\nStep the simulation using a continous time-span or until the next event happens. \n\nFor the continous simulation a step_size_s can be freely chosen, for the discrete event type  DISCRETEEVENT has to be set for the `stepsize_s`.\n\n\n\n\n\n","category":"function"},{"location":"api/#Mango.CommunicationSimulation","page":"API","title":"Mango.CommunicationSimulation","text":"Interface to implement a communication simulation. \n\n\n\n\n\n","category":"type"},{"location":"api/#Mango.CommunicationSimulationResult","page":"API","title":"Mango.CommunicationSimulationResult","text":"List of package results\n\n\n\n\n\n","category":"type"},{"location":"api/#Mango.MessagePackage","page":"API","title":"Mango.MessagePackage","text":"Struct describing a mesage between two agents.\n\n\n\n\n\n","category":"type"},{"location":"api/#Mango.PackageResult","page":"API","title":"Mango.PackageResult","text":"Package result \n\n\n\n\n\n","category":"type"},{"location":"api/#Mango.SimpleCommunicationSimulation","page":"API","title":"Mango.SimpleCommunicationSimulation","text":"Default Implementation Communication Sim.\n\nImplements a default delay which determines the delay of all messages if not specified in  delay_s_directed_edge_dict. The dict can contain a mapping (aidsender, aidreceiver) -> delay, such that the delay is specified for every link between agents.\n\n\n\n\n\n","category":"type"},{"location":"api/#Mango.calculate_communication-Tuple{CommunicationSimulation, Clock, Vector{MessagePackage}}","page":"API","title":"Mango.calculate_communication","text":"calculate_communication(communication_sim::CommunicationSimulation, clock::Clock, messages::Vector{MessagePackage})::CommunicationSimulationResult\n\nCalculate the communication using the specific communication simulation type. the current simulation time clock and the message which shall be sent in this step messages\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.calculate_communication-Tuple{SimpleCommunicationSimulation, Clock, Vector{MessagePackage}}","page":"API","title":"Mango.calculate_communication","text":"Implementation for SimpleCommunicationSimulation\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.SimpleTaskSimulation","page":"API","title":"Mango.SimpleTaskSimulation","text":"Default implementation of the interface.\n\n\n\n\n\n","category":"type"},{"location":"api/#Mango.SimulationScheduler","page":"API","title":"Mango.SimulationScheduler","text":"Specific scheduler, defined to be injected to the agents and intercept scheduling  calls and especially the sleep calls while scheduling. This struct manages all necessary times and events, which shall fulfill the purpose to step the tasks only for a given step_size.\n\n\n\n\n\n","category":"type"},{"location":"api/#Mango.TaskIterationResult","page":"API","title":"Mango.TaskIterationResult","text":"Define the result of an whole iteration of the task simulation\n\n\n\n\n\n","category":"type"},{"location":"api/#Mango.TaskResult","page":"API","title":"Mango.TaskResult","text":"Defines the result of a task.\n\n\n\n\n\n","category":"type"},{"location":"api/#Mango.TaskSimulation","page":"API","title":"Mango.TaskSimulation","text":"Abstract type to define a TaskSimulation\n\n\n\n\n\n","category":"type"},{"location":"api/#Mango.create_agent_scheduler-Tuple{TaskSimulation}","page":"API","title":"Mango.create_agent_scheduler","text":"create_agent_scheduler(task_sim::TaskSimulation)\n\nCreate the scheduler used in the agents by the given task_sim.\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.step_iteration-Tuple{TaskSimulation, Real}","page":"API","title":"Mango.step_iteration","text":"step_iteration(task_sim::TaskSimulation, step_size_s::Real)::TaskIterationResult\n\nExecute an iteration for a step of the simulation, which time is stepped with the step_size_s. \n\nCan be called repeatedly if new tasks are spawn as a result of other tasks or as result of arriving messages. \n\n\n\n\n\n","category":"method"},{"location":"api/#Scheduling","page":"API","title":"Scheduling","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"In the following the APIs for scheduling TaskData is listed.","category":"page"},{"location":"api/","page":"API","title":"API","text":"Modules = [Mango]\nPrivate = false\nPages = [\"util/scheduling.jl\"]","category":"page"},{"location":"api/#Mango.AbstractScheduler","page":"API","title":"Mango.AbstractScheduler","text":"Abstract type for a scheduler\n\n\n\n\n\n","category":"type"},{"location":"api/#Mango.AwaitableTaskData","page":"API","title":"Mango.AwaitableTaskData","text":"Schedule the function when the given awaitable is finished. Can be used  with any type for which wait is defined.\n\n\n\n\n\n","category":"type"},{"location":"api/#Mango.Clock","page":"API","title":"Mango.Clock","text":"Default clock implementation, in which a static DateTime field is used.\n\n\n\n\n\n","category":"type"},{"location":"api/#Mango.ConditionalTaskData","page":"API","title":"Mango.ConditionalTaskData","text":"Schedule the function when the condition is fulfilled. To check whether it is fulfilled the condition function is called every check_interval_s.\n\n\n\n\n\n","category":"type"},{"location":"api/#Mango.DateTimeTaskData","page":"API","title":"Mango.DateTimeTaskData","text":"Schedule the function at a specific time determined by the date::DateTime.\n\n\n\n\n\n","category":"type"},{"location":"api/#Mango.InstantTaskData","page":"API","title":"Mango.InstantTaskData","text":"Instant task data. Functions scheduled with this data is scheduled instantly.\n\n\n\n\n\n","category":"type"},{"location":"api/#Mango.PeriodicTaskData","page":"API","title":"Mango.PeriodicTaskData","text":"Task data describing a periodic task. \n\nA periodic task is defined by an interval_s and optionally by a condition. The interval determines how long the delay is between the recurring action. The condition is a stopping condition (no argument) which shall return true if the task shall stop. \n\n\n\n\n\n","category":"type"},{"location":"api/#Mango.Scheduler","page":"API","title":"Mango.Scheduler","text":"Default scheduler for the real time applications of Mango.jl.\n\n\n\n\n\n","category":"type"},{"location":"api/#Mango.TaskData","page":"API","title":"Mango.TaskData","text":"TaskData type, which is the supertype for all data structs,  which shall describe a specific task type. Together with a new method execute task for the inherting struct, new types of tasks can be introduced.\n\nExample\n\nstruct InstantTaskData <: TaskData end\nfunction execute_task(f::Function, scheduler::AbstractScheduler, data::InstantTaskData)\n    f()\nend\n\n\n\n\n\n","category":"type"},{"location":"api/#Base.schedule-Tuple{Function, AbstractScheduler, TaskData}","page":"API","title":"Base.schedule","text":"schedule(f::Function, scheduler, data::TaskData)\n\nSchedule a function (no arguments) using the specific scheduler (mostly the agent scheduler). The  functino f is scheduled using the information in data, which specifies the way f will be  scheduled.\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.sleep_until-Tuple{Function}","page":"API","title":"Mango.sleep_until","text":"sleep_until(condition::Function)\n\nSleep until the condition (no args -> bool) is met.\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.stop_all_tasks-Tuple{AbstractScheduler}","page":"API","title":"Mango.stop_all_tasks","text":"stop_all_tasks(scheduler::AbstractScheduler)\n\nStopps all stoppable tasks managed by scheduler.\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.stop_and_wait_for_all_tasks-Tuple{AbstractScheduler}","page":"API","title":"Mango.stop_and_wait_for_all_tasks","text":"stop_and_wait_for_all_tasks(scheduler::AbstractScheduler)\n\nStopps all stoppable tasks and then wait for all tasks in scheduler.\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.stop_task-Tuple{AbstractScheduler, Task}","page":"API","title":"Mango.stop_task","text":"stop_task(scheduler::AbstractScheduler, t::Task)\n\nStop the task t managed by scheduler. This only works if the task has been scheduled with the scheduler using a stoppable TaskData.\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.wait_for_all_tasks-Tuple{AbstractScheduler}","page":"API","title":"Mango.wait_for_all_tasks","text":"wait_for_all_tasks(scheduler::AbstractScheduler)\n\nWait for all tasks managed by scheduler.\n\n\n\n\n\n","category":"method"},{"location":"api/#Topology","page":"API","title":"Topology","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"In the following the APIs for creating, aplying and using topologies is listed.","category":"page"},{"location":"api/","page":"API","title":"API","text":"Modules = [Mango]\nPrivate = false\nPages = [\"world/topology.jl\"]","category":"page"},{"location":"api/#Graphs.SimpleGraphs.add_edge!","page":"API","title":"Graphs.SimpleGraphs.add_edge!","text":"add_edge!(topology, node_id_from, node_id_to, directed=false)\n\nAdd an edge to the topology from node_id_from to node_id_to. If directed is true a directed edge is added, otherwise an undirected edge is added.\n\n\n\n\n\n","category":"function"},{"location":"api/#Mango.add!-Tuple{Mango.Node, Vararg{Agent}}","page":"API","title":"Mango.add!","text":"add!(node, agent::Agent...)\n\nAdd an agents to the node.\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.add_node!-Tuple{Topology, Vararg{Agent}}","page":"API","title":"Mango.add_node!","text":"add_node!(topology, agents::Agent...)::Int\n\nAdd a node to the topology with a list (or a single) of agents attached.\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.assign_agent-Tuple{Function, Topology, ContainerInterface}","page":"API","title":"Mango.assign_agent","text":"assign_agent(assign_condition::Function, topology::Topology, container::ContainerInterface)\n\nAssign all agents of the container to the nodes based on the given assign_condition, this condition  takes as Agent and a Node (node.id for the identifier of the node) and shall return a boolean indicating whether the agent shall be assigned to the node.\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.choose_agent-Tuple{Function, Topology}","page":"API","title":"Mango.choose_agent","text":"choose_agent(choose_agent_function::Function, topology::Topology)\n\nChoose the agents, which shall be assigned to the nodes. For this the choose_agent_function has to be provided. This  function expects Node as argument and shall return an Agent or Agent.... The returned agent will be assigned to the node.\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.complete_topology-Tuple{Int64}","page":"API","title":"Mango.complete_topology","text":"complete_topology(number_of_nodes)\n\nCreate a fully-connected topology.\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.create_topology-Tuple{Function}","page":"API","title":"Mango.create_topology","text":"create_topology(create_runnable)::Topology\n\nCreate a topology using the create_runnable function which is a one-argument function with an initially empty topology as argument.\n\nExample\n\ntopology = create_topology() do topology\n    agent = register(container, TopologyAgent())\n    agent2 = register(container, TopologyAgent())\n    agent3 = register(container, TopologyAgent())\n    n1 = add_node!(topology, agent)\n    n2 = add_node!(topology, agent2)\n    n3 = add_node!(topology, agent3)\n    add_edge!(topology, n1, n2)\n    add_edge!(topology, n1, n3)\nend\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.cycle_topology-Tuple{Int64}","page":"API","title":"Mango.cycle_topology","text":"cycle_topology(number_of_nodes)\n\nCreate a cycle topology.\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.graph_topology-Tuple{Graphs.AbstractGraph}","page":"API","title":"Mango.graph_topology","text":"graph_topology(graph)\n\nCreate a topology based on a Graphs.jl (abstract) graph.\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.modify_topology-Tuple{Function, Topology}","page":"API","title":"Mango.modify_topology","text":"modify_topology(modify_runnable::Functino, topology::Topology)\n\nModify a topology using the modify_runnable function which is a one-argument function with the provided topology as argument.\n\nExample\n\nmodify_topology(my_topology) do topology\n    agent = register(container, TopologyAgent())\n    agent2 = register(container, TopologyAgent())\n    agent3 = register(container, TopologyAgent())\n    n1 = add_node!(topology, agent)\n    n2 = add_node!(topology, agent2)\n    n3 = add_node!(topology, agent3)\n    add_edge!(topology, n1, n2)\n    add_edge!(topology, n1, n3)\nend\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.per_node-Tuple{Function, Topology}","page":"API","title":"Mango.per_node","text":"per_node(assign_runnable, topology)\n\nLoops over the nodes of the topology, calls assign_runnable on every node to enable the caller to populate the node. After the loop finished the neighborhoods are created and injected into the agent. \n\nExample\n\nper_node(topology) do node\n    add!(node, register(container, TopologyAgent()))\nend\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.remove_edge!-Tuple{Topology, Int64, Int64}","page":"API","title":"Mango.remove_edge!","text":"remove_edge!(topology::Topology, node_id_from::Int, node_id_to::Int)\n\nRemove the edge between node_id_from and node_id_to.\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.remove_node!-Tuple{Topology, Int64}","page":"API","title":"Mango.remove_node!","text":"remove_node!(topology::Topology, node_id::Int)\n\nRemove the node with the id node_id.\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.set_edge_state!-Tuple{Topology, Int64, Int64, Mango.State}","page":"API","title":"Mango.set_edge_state!","text":"set_state!(topology::Topology, node_id_from::Int, node_id_to::Int, state::State)\n\nSet the state of the state of the edge (node_id_from, node_id_to) to state.\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.star_topology-Tuple{Int64}","page":"API","title":"Mango.star_topology","text":"star_topology(number_of_nodes)\n\nCreate a star topology.\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.topology_neighbors","page":"API","title":"Mango.topology_neighbors","text":"topology_neighbors(agent)\n\nRetrieve the neighbors of the agent, represented by their addresses. These vaues will be updated when a topology is applied using per_node or create_topology.\n\n\n\n\n\n","category":"function"},{"location":"api/#Encoding/Decoding","page":"API","title":"Encoding/Decoding","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"In the following the built-in functions for encoding and decoding messages are listed.","category":"page"},{"location":"api/","page":"API","title":"API","text":"Modules = [Mango]\nPrivate = false\nPages = [\"util/encode_decode.jl\"]","category":"page"},{"location":"api/#Mango.decode","page":"API","title":"Mango.decode","text":"decode(buf::Vector{UInt8}, t::Type=OrderedDict{String, Any})\n\nDecode the data in buf into an object of type t using LightBSON.bson_read.\n\nExamples\n\njulia> data = OrderedDict([\"test\" => 10])\nOrderedDict{String, Int64} with 1 entry:\n  \"test\" => 10\n\njulia> decode(encode(data))\nOrderedDict{String, Any} with 1 entry:\n  \"test\" => 10\n\n\n\n\n\n","category":"function"},{"location":"api/#Mango.encode-Tuple{Any}","page":"API","title":"Mango.encode","text":"encode(data::OrderedDict{String,Any})\n\nEncode data into a UInt8 buffer using LightBSON.\n\nExamples\n\njulia> data = OrderedDict([\"test\" => 10])\nOrderedDict{String, Int64} with 1 entry:\n  \"test\" => 10\n\njulia> encode(data)\n19-element Vector{UInt8}:\n 0x13\n 0x00\n 0x00\n 0x00\n 0x12\n    ⋮\n 0x00\n 0x00\n 0x00\n 0x00\n 0x00\n\n\n\n\n\n","category":"method"},{"location":"api/#Misc","page":"API","title":"Misc","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [Mango]\nPrivate = false\nPages = [\"util/datastructures_util.jl\"]","category":"page"},{"location":"api/#Mango.@with_def-Tuple{Any}","page":"API","title":"Mango.@with_def","text":"This macro can be applied to struct definitions and adds the possibility to define default values on field declaration. In contrast to @kwdef or @with_kw, this macro will create normal parameters for construction if no default value has been provided.\n\nExample\n\n@with_def struct ExampleStruct\n    abc::Int = 0\n    def::String\nend\n\n# can be constructed as follows\nes = ExampleStruct(\"mydefstring\") # abc == 0\nes = ExampleStruct(\"mydefstring\", abc=3) # abc == 3\n\n\n\n\n\n","category":"macro"},{"location":"simulation/#Simulation-Container","page":"Simulation","title":"Simulation Container","text":"","category":"section"},{"location":"simulation/","page":"Simulation","title":"Simulation","text":"The simulation container has the same role as the real-time container and therefore acts as communication and interaction interface to the environment. The simulation container maintains an interal simulation time and only executes tasks and delivers messages according to the requested step_sizes. It can be stepped in the continous mode or the discrete event mode. Further the container manages a common environment the agents can interact with as base structure for agent-based modeling simulations.","category":"page"},{"location":"simulation/#Create-and-stepping-a-simulation-container","page":"Simulation","title":"Create and stepping a simulation container","text":"","category":"section"},{"location":"simulation/","page":"Simulation","title":"Simulation","text":"To create a simulation container, it is advised to use create_simulation_container. This method will create a clock with the given simulation time and set default for the communication simulation and the general task simulation. In most cases the default task simulation will be what you desire. The communication simulation object (based on the abstract type CommunicationSimulation) is used to determine the delays of the messages in the simulation, while the task simulation determines the way the tasks are scheduled (within a time step, using parallelization etc.) in the simulation. ","category":"page"},{"location":"simulation/","page":"Simulation","title":"Simulation","text":"In the following example a simple simulation is executed.","category":"page"},{"location":"simulation/","page":"Simulation","title":"Simulation","text":"using Mango, Dates\n\n# Arbitrary agent definition\n@agent struct SimAgent\nend\n\n# Create a communication simulator, the simple communication simulator works with static delays between specific agents and a global default, here 0\ncomm_sim = SimpleCommunicationSimulation(default_delay_s=0)\n# Set the simulation time to an initial value\ncontainer = create_simulation_container(DateTime(Millisecond(10)), communication_sim=comm_sim)\n\n# Creating agents and registering, no difference here to the real time container\nagent1 = register(container, SimAgent())\nagent2 = register(container, SimAgent())\n\n# Send a message from agent2 to agent1, the message will be written to a queue instead of processed by some protocol\nsend_message(agent2, \"Hello Friends, this is RSc!\", AgentAddress(aid=agent1.aid))\n\n# in this stepping call the message will be delivered and handled to/by the agent1  \n# step_size=1, if no size is specified the simulation will work as discrete event simulation, executing all tasks occurring on the next event time.\nstepping_result = step_simulation(container, 1)\n\n@info stepping_result.time_elapsed\n@info container.clock","category":"page"},{"location":"simulation/#Discrete-event-vs-continous-stepping","page":"Simulation","title":"Discrete event vs continous stepping","text":"","category":"section"},{"location":"simulation/","page":"Simulation","title":"Simulation","text":"Mango.jl support discrete event and continous stepping. Discrete event stepping means that no advance time is provided instead the simulation jumps to the next event time and executes every tasks, delivers every message scheduled at this next event time. For example, you set up a simultion in which three tasks are in the queue at the event times 1,1,3; then the next step would execute the first two, and the following would execute the last task (given no new tasks are created). With continous stepping the user has to provide a stepsize (in seconds), which will be used to execute every task until `simulationtime + step_size` ordered by the time of the individual tasks. It is also possible to mix both styles.","category":"page"},{"location":"simulation/","page":"Simulation","title":"Simulation","text":"# function call examples for\n# continous\nstepping_result = step_simulation(container, 1.23)\n# and\n# discrete event\nstepping_result = step_simulation(container)","category":"page"},{"location":"simulation/","page":"Simulation","title":"Simulation","text":"If you do not require to mix both styles and you do not want to create very specific simulations containers, you might prefer to use the express way:","category":"page"},{"location":"simulation/","page":"Simulation","title":"Simulation","text":"using Mango, Dates\n\n# Arbitrary agent definition\n@agent struct SteppingAgent\nend\n\n# number of steps, agents..., start_time=Start time of simulation\nresults = run_in_simulation(1, SteppingAgent(), PrintingAgent(), start_time=DateTime(2000)) do container\n    send_message(container, \"MyMessageForTheSimulation\", address(container[2]))\nend","category":"page"},{"location":"simulation/#Communication-simulation","page":"Simulation","title":"Communication simulation","text":"","category":"section"},{"location":"simulation/","page":"Simulation","title":"Simulation","text":"Mango.jl is generally designed to be extenable, this is also true for the usage of a communication simulator in a Mango.jl-Simulation. To use a custom communication simulator, you can simply set the keyword argument communication_sim to a struct of the abstract type CommunicationSimulation. To implement this type, you need to add a fitting method to Mango.calculate_communication::CommunicationSimulation, clock::Clock, messages::Vector{MessagePackage})::CommunicationSimulationResult. This method will then be called in the simulation loop at least once and repeatedly when new messages arrive and therefore a new state has to be determined.","category":"page"},{"location":"simulation/","page":"Simulation","title":"Simulation","text":"The default communication simulator is SimpleCommunicationSimulation. This simulator uses a default static delay together with a dictionary containing delays per link between individual agents.","category":"page"},{"location":"simulation/#Agent-based-modeling","page":"Simulation","title":"Agent-based modeling","text":"","category":"section"},{"location":"simulation/","page":"Simulation","title":"Simulation","text":"The simulation container can also be used for simple agent-based modeling simulations. In agent-based modeling, units (e.g. people, cars, ...) are modeled using agents and their interaction between these agents and further units in a common world/environment. To support this the simulation container provides on_step(agent::Agent, world::World, clock::Clock, step_size_s::Real) (also defined on Role). ","category":"page"},{"location":"simulation/","page":"Simulation","title":"Simulation","text":"The World can contain common objects to interact with and contains a Space struct which can define the type of world modeled (2D/3D/Graph/...). This struct also contains the positions of all agents. Currently there is only the Space2D implementation with simple cartesian coordinates. ","category":"page"},{"location":"simulation/","page":"Simulation","title":"Simulation","text":"Please note that Mango.jl focuses on agent-based control, agent-based communication and therefore currently does not provide much supporting implementations for complex agent-based modeling simulations.","category":"page"},{"location":"topology/#Topologies","page":"Topologies","title":"Topologies","text":"","category":"section"},{"location":"topology/","page":"Topologies","title":"Topologies","text":"In Mango.jl agents usually communicate with each other based on a topology. The topology determines which agent can communicate with which agent. To implement this, every agent has access to a neighborhood, which is the set of all agents it can communicate with. ","category":"page"},{"location":"topology/","page":"Topologies","title":"Topologies","text":"As it can be pretty clunky to create every neighborhood-list manually, Mango.jl provides several functions to make your life easier. For this it relys on Graphs.jl and MetaGraphsNext.jl as datastructure and for graph-construction","category":"page"},{"location":"topology/#Creating-topologies","page":"Topologies","title":"Creating topologies","text":"","category":"section"},{"location":"topology/","page":"Topologies","title":"Topologies","text":"First, there are several pre-defined topologies. It is also possible to use an arbitrary Graphs.jl graph. After the creation of the topology, the agents need to be added to the topology. This can be done with per_node(topology) do node ... end. In the do-block it is possible to add agents to nodes, the do-block will be executed per vertex of your graph. ","category":"page"},{"location":"topology/","page":"Topologies","title":"Topologies","text":"using Mango, Graphs\n\n@agent struct MyAgent end\n\ntopology = star_topology(3) # star\ntopology = cycle_topology(3) # cycle\ntopology = complete_topology(3) # fully connected \ntopology = graph_topology(complete_digraph(3)) # based on arbitrary Graphs.jl AbstractGraph\n\nper_node(topology) do node\n    add!(node, MyAgent())\nend\n\n# resulting topology graph\ntopology.graph","category":"page"},{"location":"topology/","page":"Topologies","title":"Topologies","text":"However, often this approach is not feasible, because you create a specific agent system with agents which need to be linked in a very specific way, such that it is not possible to assign the same agent type to every node. For this reason you can define the topology manually:","category":"page"},{"location":"topology/","page":"Topologies","title":"Topologies","text":"using Mango \n\n@agent struct TopologyAgent end\ncontainer = Container()\n\ntopology = create_topology() do topology\n    agent0 = register(container, TopologyAgent())\n    agent1 = register(container, TopologyAgent())\n    agent2 = register(container, TopologyAgent())\n    n1 = add_node!(topology, agent0)\n    n2 = add_node!(topology, agent1)\n    n3 = add_node!(topology, agent2)\n    add_edge!(topology, n1, n2)\n    add_edge!(topology, n1, n3)\nend\n\n# neighbors of `agent`\ntopology_neighbors(container[1])","category":"page"},{"location":"topology/#Using-the-topology","page":"Topologies","title":"Using the topology","text":"","category":"section"},{"location":"topology/","page":"Topologies","title":"Topologies","text":"At this point we know how to create topologies and how to populate them. To actually use them, the function topology_neighbors exists. The function returns a vector of AgentAddress objects, which represent all other agents in the neighborhood of agent.","category":"page"},{"location":"container/#Real-Time-Container","page":"Container","title":"Real Time Container","text":"","category":"section"},{"location":"container/","page":"Container","title":"Container","text":"The real time container feature in Mango.jl allows you to create and manage a container, which acts as the communication layer within the environment. A container is responsible for handling messages, forwarding them to the appropriate agents, and managing agent registration. The real time component means that the container acts on a real time clock, and does not differentiate between a simulation time and the execution time, which essentially means everything executed withing the real time container is executed immediately as stated in the code. In contrast, there is also a \"simulation\" container, which maintains an interal simulation time and only executes tasks and delivers messages according to the requested step_sizes (next event time). More on the simulation container can be found under Simulation Container. Note, that both container types implement the methods for the ContainerInterface and can therefore be drop-in replacements for the each other with slight differences in usage.","category":"page"},{"location":"container/#Container-Struct","page":"Container","title":"Container Struct","text":"","category":"section"},{"location":"container/","page":"Container","title":"Container","text":"The Container struct represents the container as an actor within the environment. It is implemented using composition, making it flexible to use different protocols and codecs for message communication. The key components of the Container struct are:","category":"page"},{"location":"container/","page":"Container","title":"Container","text":"protocol: The protocol used for message communication (e.g., TCP).\ncodec: A pair of functions for encoding and decoding messages in the container.","category":"page"},{"location":"container/#Start-and-Shutdown","page":"Container","title":"Start and Shutdown","text":"","category":"section"},{"location":"container/","page":"Container","title":"Container","text":"Before using the container for message handling and agent management, you need to start the container using the start function. This function initializes the container's components and enables it to act as the communication layer. After you are done with the container, shutdown has to be called.","category":"page"},{"location":"container/","page":"Container","title":"Container","text":"using Mango\n\n# Create a container instance\ncontainer = Container()\n\n# ... setup the container, agents, define handles, ...\n\n# Start the container\nwait(Threads.@spawn start(container))\n\n# Execute some functionality to e.g. trigger the agent system\n\n# Shut down the container\nshutdown(container)\n@info \"Agent container and agents shutdown\"","category":"page"},{"location":"container/","page":"Container","title":"Container","text":"However, this approach can be error-prone for multiple reasons. Besides simply forgetting to call shutdown, an exception may occur between the start and shutdown calls on the containers, leading to resource leaks. For this reason, we recommend using activate instead. With this function, the above `start/shutdown' pair translates to...","category":"page"},{"location":"container/","page":"Container","title":"Container","text":"# Start the container and shut it down after the runnable (do ... end) has been executed.\nactivate(container) do\n\n# Execute some functionality to e.g. trigger the agent system\n\nend","category":"page"},{"location":"container/#Registering-Agents","page":"Container","title":"Registering Agents","text":"","category":"section"},{"location":"container/","page":"Container","title":"Container","text":"To enable the container to manage agents and handle their messaging activities, you can register agents using the register function. This function associates an agent with a unique agent ID (AID) and adds the agent to the container's internal list.","category":"page"},{"location":"container/","page":"Container","title":"Container","text":"using Mango\n\n# Create a container instance\ncontainer = Container()\n\n# Define and create an agent\n@agent struct MyAgent\n    # Your agent's fields and methods here\nend\n\nmy_agent = MyAgent()\n\n# Register the agent with the container\nregister(container, my_agent)","category":"page"},{"location":"container/#Sending-Messages","page":"Container","title":"Sending Messages","text":"","category":"section"},{"location":"container/","page":"Container","title":"Container","text":"To send messages between agents within the container, you can use the send_message function. The container routes the message to the specified receiver agent based on the receiver's AID.","category":"page"},{"location":"container/","page":"Container","title":"Container","text":"using Mango\n\n# Create a container instance\ncontainer = Container()\nagent = register(container, PrintingAgent())\n\n# ... Register agents ...\n\n# Sending a message from one agent to another\nwait(send_message(container, \"Hello from Agent 1!\", address(agent)))","category":"page"},{"location":"container/#TCP","page":"Container","title":"TCP","text":"","category":"section"},{"location":"container/","page":"Container","title":"Container","text":"This protocol allows communication over plain TCP connections, enabling message exchange between different entities within the Mango.jl simulation environment.","category":"page"},{"location":"container/#Introduction","page":"Container","title":"Introduction","text":"","category":"section"},{"location":"container/","page":"Container","title":"Container","text":"The TCP Protocol in Mango.jl is a communication protocol used to exchange messages over plain TCP connections. It enables agents within the simulation environment to communicate with each other by establishing and managing TCP connections.","category":"page"},{"location":"container/#TCPProtocol-Struct","page":"Container","title":"TCPProtocol Struct","text":"","category":"section"},{"location":"container/","page":"Container","title":"Container","text":"The TCPProtocol struct represents the TCP Protocol within Mango.jl. It encapsulates the necessary functionalities for communication via TCP connections. Key features of the TCPProtocol struct are:","category":"page"},{"location":"container/","page":"Container","title":"Container","text":"address: The InetAddr represents the address on which the TCP server listens.\nserver: A TCPServer instance used for accepting incoming connections.","category":"page"},{"location":"container/#Usage","page":"Container","title":"Usage","text":"","category":"section"},{"location":"container/","page":"Container","title":"Container","text":"To use the tcp protocol you need to construct a TCPProtocol struct and assign it to the protocol field in the container.","category":"page"},{"location":"container/","page":"Container","title":"Container","text":"using Mango, Sockets\n\ncontainer2 = Container()\ncontainer2.protocol = TCPProtocol(address=Sockets.InetAddr(\"127.0.0.2\", 2940))","category":"page"},{"location":"container/","page":"Container","title":"Container","text":"It is also possible to use the convenience function create_tcp_container.","category":"page"},{"location":"container/","page":"Container","title":"Container","text":"using Mango \n\ncontainer2 = create_tcp_container(\"127.0.0.2\", 2940)","category":"page"},{"location":"container/#MQTT","page":"Container","title":"MQTT","text":"","category":"section"},{"location":"container/#Introduction-2","page":"Container","title":"Introduction","text":"","category":"section"},{"location":"container/","page":"Container","title":"Container","text":"The MQTT protocol enables sending via an MQTT message broker. It allows a container to subscribe to different topics on a broker and publish messages to them.","category":"page"},{"location":"container/","page":"Container","title":"Container","text":"Currently, one container may only connect to a single broker. Subscribed topics for each agent are set on agent registration and tracked by the container. Incoming messages on these topics are distributed to the subscribing agents by the container.","category":"page"},{"location":"container/#MQTTProtocol-Struct","page":"Container","title":"MQTTProtocol Struct","text":"","category":"section"},{"location":"container/","page":"Container","title":"Container","text":"The MQTTProtocol contains the status and channels of the underlying mosquitto C library (as abstracted to Julia by the Mosquitto.jl package).","category":"page"},{"location":"container/","page":"Container","title":"Container","text":"The constructor takes a client_id and the broker_addr. Internally it also tracks the msg_channel and conn_channel, internal flags, the information to map topics to subscribing agents.","category":"page"},{"location":"container/","page":"Container","title":"Container","text":"protocol = MQTTProtocol(cliant_id, broker_addr)","category":"page"},{"location":"container/","page":"Container","title":"Container","text":"client_id - String id the container will communicate to the MQTT broker.\nbroker_addr - InetAddr of the MQTT broker","category":"page"},{"location":"container/#Usage-2","page":"Container","title":"Usage","text":"","category":"section"},{"location":"container/","page":"Container","title":"Container","text":"To use the mqtt protocol you need to construct a MQTTProtocol struct and assign it to the protocol field in the container. Further it is possible to use a convenience function for this  It is also possible to use the convenience function create_mqtt_container.","category":"page"},{"location":"container/","page":"Container","title":"Container","text":"using Mango, Sockets\n\ncontainer2 = Container()\ncontainer2.protocol = MQTTProtocol(\"my_id\", Sockets.InetAddr(ip\"127.0.0.2\", 2940))","category":"page"},{"location":"container/","page":"Container","title":"Container","text":"note: Running MQTT broker expected\nThe MQTT protocol expects an MQTT broker to run at the specified host and port.","category":"page"},{"location":"container/","page":"Container","title":"Container","text":"Subscribing an agent to a topic can happen only as registration time and is not allowed otherwise. When registering a new agent to the container the topics to subscribe are passed by the topics keyword argument, taking a collection of String topic names. NOTE: It is recommended you pass a Vector{String} as this is what is tested.  Other collections could work but no guarantees are given.","category":"page"},{"location":"container/","page":"Container","title":"Container","text":"using Mango\n\ncontainer2 = create_mqtt_container(\"127.0.0.2\", 2940, \"MyMqttClient\")\n\na1 = PrintingAgent()\nregister(container2, a1; topics=[\"topic1\", \"topic2\"])","category":"page"},{"location":"getting_started/#Getting-Started-with-Mango.jl","page":"Getting Started","title":"Getting Started with Mango.jl","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"In this getting started guide, we will explore the essential features of Mango.jl, starting with a simple example using the express-api, followed by a more in-depth example of two ping pong agents that exchange messages in a container. Here, we will manually set up a container with the TCP protocol, define ping pong agents, and enable them to exchange messages. This way allows better customization but may need more boilerplate code.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"You can also find working examples of the following code in examples.jl.","category":"page"},{"location":"getting_started/#.-Quickstart","page":"Getting Started","title":"0. Quickstart","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"In Mango.jl, you can define agents using a number of roles using @role and agent_composed_of, or directly using @agent. To define the behavior of the agents, handle_message can be defined, and messages can be send using send_message. To run the agents with a specific protocol in real time the fastest way is to use run_with_tcp, which will distribute the agents to tcp-containers and accepts a function in which some agent intializiation and/or trigger-code could be put. The following example illustrates the basic usage of the functions.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"using Mango\n\n@role struct PrintingRole\n    out::Any = \"\"\nend\n\nfunction Mango.handle_message(role::PrintingRole, msg::Any, meta::AbstractDict)\n    role.out = msg\nend\n\nexpress_one = agent_composed_of(PrintingRole())\nexpress_two = agent_composed_of(PrintingRole(), PrintingRole())\n\nrun_with_tcp(2, express_one, express_two) do container_list\n    wait(send_message(express_one, \"Ping\", address(express_two)))\n    sleep_until(() -> express_two[1].out == \"Ping\")\nend\n\n# evaluating\nexpress_two[1].out\n# output\n\"Ping\"","category":"page"},{"location":"getting_started/#Step-by-step-(manual-container-creation)","page":"Getting Started","title":"Step-by-step (manual container creation)","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Alternatively you can create the container yourself. This is the more flexible approach, but also wordier.","category":"page"},{"location":"getting_started/#.-Creating-a-Container-with-a-TCP-Protocol","page":"Getting Started","title":"1. Creating a Container with a TCP Protocol","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"we need to create a container to manage ping pong agents and facilitate communication using the TCP protocol:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"using Mango, Sockets\n\n# Create the container instances with TCP protocol\ncontainer = create_tcp_container(\"127.0.0.1\", 5555)\ncontainer2 = create_tcp_container(\"127.0.0.1\", 5556)","category":"page"},{"location":"getting_started/#.-Defining-Ping-Pong-Agents","page":"Getting Started","title":"2. Defining Ping Pong Agents","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Let's define agent structs to represent the ping pong agents. Every new agent struct should be defined using the @agent macro to ensure compatibility with the mango container:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"# Define the ping pong agent\n@agent struct TCPPingPongAgent\n    counter::Int\nend","category":"page"},{"location":"getting_started/#.-Sending-and-Handling-Messages","page":"Getting Started","title":"3. Sending and Handling Messages","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Ping pong agents can exchange messages and they can keep track of the number of messages received. Let's implement message handling for the agents. To achieve this a new method handle_message from Mango has to be added:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"# Override the default handle_message function for ping pong agents\nfunction Mango.handle_message(agent::TCPPingPongAgent, message::Any, meta::Any)\n    agent.counter += 1\n\n    println(\n        \"$(agent.aid) got a message: $message.\" *\n        \"This is message number: $(agent.counter) for me!\"\n    )\n\n    # doing very important work\n    sleep(0.5)\n\n    if message == \"Ping\"\n        reply_to(agent, \"Pong\", meta)\n    elseif message == \"Pong\"\n        reply_to(agent, \"Ping\", meta)\n    end\nend","category":"page"},{"location":"getting_started/#.-Sending-Messages","page":"Getting Started","title":"4. Sending Messages","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Now let's simulate the ping pong exchange by sending messages between the ping pong agents.  Addresses are provided to the send_message function via the AgentAddress struct. The struct consists of an aid and the more technical address field. Further an AgentAddress  can contain a tracking_id, which can identify the dialog agents are having.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"The send_message method here will automatically insert the agent as sender:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"# Define the ping pong agent\n# Create instances of ping pong agents\nping_agent = register(container, TCPPingPongAgent(0))\npong_agent = register(container2, TCPPingPongAgent(0))\n\nactivate([container, container2]) do\n    # Send the first message to start the exchange\n    send_message(ping_agent, \"Ping\", address(pong_agent))\n\n    # wait for 5 messages to have been sent\n    sleep_until(() -> ping_agent.counter >= 5)\nend","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"In this example, the ping pong agents take turns sending \"Ping\" and \"Pong\" messages to each other, incrementing their counters. After a short moment, we can see the result of the ping pong process.","category":"page"},{"location":"getting_started/#.-Using-the-MQTT-Protocol","page":"Getting Started","title":"5. Using the MQTT Protocol","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"To use an MQTT messsage broker instead of a direkt TCP connection, you can use the MQTT protocol. This protocol requires a running MQTT broker. For this you can, for example, use Mosquitto as broker. On most linux-based systems mosquitto exists as package in the public repostories. For example for debian systems:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"sudo apt install mosquitto\nsudo service mosquitto start","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"After, you can create MQTT container.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"using Mango\n\nc1 = create_mqtt_container(\"127.0.0.1\", 1883, \"PingContainer\")\nc2 = create_mqtt_container(\"127.0.0.1\", 1883, \"PongContainer\")","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"The topics each agent subscribes to on the broker are provided during registration to the container. All messages on these topics will then be forwarded as messages to the agent.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"# Define the ping pong agent\n@agent struct MQTTPingPongAgent\n    counter::Int\nend\n\n# Define the ping pong agent\n# Create instances of ping pong agents\n# register each agent to a container\n# For the MQTT protocol, topics for each agent have to be passed here.\nping_agent = register(c1, MQTTPingPongAgent(0); topics=[\"pongs\"])\npong_agent = register(c2, MQTTPingPongAgent(0); topics=[\"pings\"])","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Just like the TCPProtocol, the MQTTProtocol has an associated struct for providing address information:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"the broker address\nthe topic","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Thus, sending of the first message and the handle_message definition becomes:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Lastly, handle_message has to be altered to send the corresponding answers correctly:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"# Override the default handle_message function for ping pong agents\nfunction handle_message(agent::MQTTPingPongAgent, message::Any, meta::Any)\n    broker_addr = agent.context.container.protocol.broker_addr\n\n    if message == \"Ping\"\n        agent.counter += 1\n        send_message(agent, \"Pong\", MQTTAddress(broker_addr, \"pongs\"))\n    elseif message == \"Pong\"\n        agent.counter += 1\n        send_message(agent, \"Ping\", MQTTAddress(broker_addr, \"pings\"))\n    end\nend\n\nactivate([c1, c2]) do\n    # Send the first message to start the exchange\n    send_message(ping_agent, \"Ping\", MQTTAddress(broker_addr, \"pings\"))\n    sleep_until(() -> ping_agent.counter >= 5)\nend","category":"page"},{"location":"#Mango.jl","page":"Home","title":"Mango.jl","text":"","category":"section"},{"location":"#Welcome-to-mango's-documentation!","page":"Home","title":"Welcome to mango's documentation!","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Mango.jl allows the user to create simple agents with little effort and at the same time offers options to structure agents with complex behaviour. The main features of mango are listed below.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Mango.jl as a package is partly based on the ideas of mango-agents, but will also contain new concepts and techniques. It was made with the picture of scalable agent simulations in mind.","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Container mechanism to speedup local message exchange\nStructuring complex agents with loose coupling and agent roles\nBuilt-in codecs\nSupports communication between agents directly via TCP and MQTT\nBuilt-in tasks mechanisms for proactive agent actions\nContinous and discrete stepping simulation using an external clock to rapidly run and inspect simulations designed for longer time-spans\nIntegrated communication and task simulation modules\nIntegrated environment with which the agents can interact in a common space","category":"page"},{"location":"#Development-state","page":"Home","title":"Development state","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Mango.jl is in an early development state. Feel free to try out the framework if you are interested and be aware that there might be some unexpected edges here and there.","category":"page"},{"location":"#License","page":"Home","title":"License","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Mango.jl is developed and published under the MIT license.","category":"page"},{"location":"role/#Roles","page":"Roles","title":"Roles","text":"","category":"section"},{"location":"role/","page":"Roles","title":"Roles","text":"Roles are used to provide a mechanism for reusability and modularization of functionsalities provided/implemented by agents. Every agent can contain and unlimited number of roles, which are separate structs on which typical agent functionalitites (like send_message) can be defined. All roles of an agent share the same address and agent id, as they are part of the agent and no autonomous unit for themself. ","category":"page"},{"location":"role/#Role-definition","page":"Roles","title":"Role definition","text":"","category":"section"},{"location":"role/","page":"Roles","title":"Roles","text":"A role can be defined using the @role macro. This macro adds some baselinefields to the following struct definition. The struct can be defined like any other Julia struct.","category":"page"},{"location":"role/","page":"Roles","title":"Roles","text":"using Mango\n\n# Define your role struct using @role macro\n@role struct MyRole\n    my_own_field::String\nend\n\n# Assume you have already defined roles using Mango.AgentRole module\nrole1 = MyRole(\"Role1\")","category":"page"},{"location":"role/","page":"Roles","title":"Roles","text":"Most functions, used for agent development can also be used with roles (e.g. handle_message, address, schedule, send_message (plus variants) and the lifecycle methods).  ","category":"page"},{"location":"role/","page":"Roles","title":"Roles","text":"Additionally, roles can define the setup function to define actions to take when the roles are added to the agent. It is also possible to subscribe to specific messages using a boolean expression with the subscribe_message function. With the @role macro, the role context is added to the role, which contains the reference to the agent. However, it is recommended to use the equivalent methods defined on the role to execute actions like scheduling and sending messages. Further with roles it is possible to listen to all messages sent from within the agent. For this subscribe_send can be used.","category":"page"},{"location":"role/#Role-communication","page":"Roles","title":"Role communication","text":"","category":"section"},{"location":"role/","page":"Roles","title":"Roles","text":"Besides the message subscriptions there are functionalities to communicate/work together with other roles. There are two different mechanisms for this:","category":"page"},{"location":"role/","page":"Roles","title":"Roles","text":"Data sharing\nAn event system","category":"page"},{"location":"role/#Data-sharing","page":"Roles","title":"Data sharing","text":"","category":"section"},{"location":"role/","page":"Roles","title":"Roles","text":"The data sharing can be used using ordinary Julia structs with default constructors. There are two ways to share the data, first you can create the model you want share with get_model","category":"page"},{"location":"role/","page":"Roles","title":"Roles","text":"using Mango\n\n@role struct SharedModelTestRole end\nstruct TestModel\n    c::Int64\nend\nTestModel() = TestModel(42)\n\nagent = agent_composed_of(SharedModelTestRole())\nshared_model = get_model(agent[1], TestModel)","category":"page"},{"location":"role/","page":"Roles","title":"Roles","text":"Mango.jl will create a TestModel instance and manage this instance such that every role can access it. ","category":"page"},{"location":"role/","page":"Roles","title":"Roles","text":"Although this is a straightforward method it can be very clumsy to use. For this reason there is the macro @shared, which can be used within a role definition to mark a field as shared model. Then, Mango.jl will ensure that a shared instance of the declared type will be created and assigned to the struct field.","category":"page"},{"location":"role/","page":"Roles","title":"Roles","text":"@role struct SharedFieldTestRole\n    @shared \n    test_model::TestModel\nend\n\nagent_including_test_role = agent_composed_of(SharedFieldTestRole())\nagent_including_test_role[1].test_model","category":"page"},{"location":"role/#Event-system","page":"Roles","title":"Event system","text":"","category":"section"},{"location":"role/","page":"Roles","title":"Roles","text":"Roles can emit events using emit_event. If event_type is nothing, the type of event will be used as event_type. To handle these events roles can subscribe using subscribe_event or add a method to handle_event.","category":"page"},{"location":"role/","page":"Roles","title":"Roles","text":"using Mango\n\nstruct TestEvent end\n\nfunction Mango.handle_event(role::Role, src::Role, event::TestEvent; event_type::Any)\n    @info \"Event is arriving!\" role.name\nend\nfunction custom_handler(role::Role, src::Role, event::Any, event_type::Any)\n    @info \"Event is also arriving!\"\nend\n\n@agent struct RoleTestAgent end\n@role struct MyEventRole \n    name::String\nend\n\nrole_emitter = MyEventRole(\"emitter\")\nrole_handler = MyEventRole(\"handler\")\nagent = agent_composed_of(role_emitter, role_handler; base_agent=RoleTestAgent())\n\nsubscribe_event(role_handler, TestEvent, custom_handler, (src, event) -> true) # condition is optional\n\nemit_event(role_emitter, TestEvent())","category":"page"}]
}
