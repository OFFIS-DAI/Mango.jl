var documenterSearchIndex = {"docs":
[{"location":"scheduling/#Scheduling","page":"Scheduling","title":"Scheduling","text":"","category":"section"},{"location":"scheduling/#.-Introduction","page":"Scheduling","title":"1. Introduction","text":"","category":"section"},{"location":"scheduling/","page":"Scheduling","title":"Scheduling","text":"Welcome to the documentation for the Scheduling component in Mango.jl. This utility component provides a flexible scheduler for executing predefined tasks. It offers various TaskData types to specify different task execution behaviors.","category":"page"},{"location":"scheduling/#.-Module-Overview","page":"Scheduling","title":"2. Module Overview","text":"","category":"section"},{"location":"scheduling/","page":"Scheduling","title":"Scheduling","text":"The Scheduling module exports several types and functions to facilitate task scheduling and execution. Let's briefly review the main components of this module.","category":"page"},{"location":"scheduling/#Task-Data-Types","page":"Scheduling","title":"Task Data Types","text":"","category":"section"},{"location":"scheduling/","page":"Scheduling","title":"Scheduling","text":"The module provides different TaskData types, each catering to specific scheduling requirements:","category":"page"},{"location":"scheduling/","page":"Scheduling","title":"Scheduling","text":"PeriodicTaskData: For tasks that need to be executed periodically, it holds the time interval in seconds between task executions.\nInstantTaskData: For tasks that need to be executed instantly, without any delay.\nDateTimeTaskData: For tasks that need to be executed at a specific date and time.\nAwaitableTaskData: For tasks that require waiting for an awaitable object to complete before execution.\nConditionalTaskData: For tasks that execute based on a specific condition at regular intervals.","category":"page"},{"location":"scheduling/#Typical-usage","page":"Scheduling","title":"Typical usage","text":"","category":"section"},{"location":"scheduling/","page":"Scheduling","title":"Scheduling","text":"Typically the scheduler is used within methods from the agent. To schedule a task the function schedule can be used. It takes two inputs: The agent (which forwards the call to its scheduler) and the TaskData object of the task.","category":"page"},{"location":"scheduling/","page":"Scheduling","title":"Scheduling","text":"agent = MyAgent(0)\nresult = 0\n\nschedule(agent, InstantTaskData()) do \n    # some expensive calculation\n    result = 10       \nend\nwait_for_all_tasks(agent)","category":"page"},{"location":"scheduling/","page":"Scheduling","title":"Scheduling","text":"PeriodicTaskData creates tasks that get executed repeatedly forever.  This means that calling wait on such a task will generally simply block forever. For this reason a periodic task has to be stopped before it can be waited on.","category":"page"},{"location":"scheduling/","page":"Scheduling","title":"Scheduling","text":"delay_in_s = 0.5 # delay between executions of the task in seconds\n\nt = schedule(agent, PeriodicTaskData(delay)) do \n    # some expensive calculation\n    result = 10       \nend\n\nstop_task(agent, t)\nwait_for_all_tasks(agent)","category":"page"},{"location":"scheduling/","page":"Scheduling","title":"Scheduling","text":"Alternatively, you can stop all stopable tasks simultaneously with the stop_all_tasks function.","category":"page"},{"location":"scheduling/","page":"Scheduling","title":"Scheduling","text":"delay_in_s = 0.5 # delay between executions of the task in seconds\n\nfor i in 1:100\n    schedule(agent, PeriodicTaskData(delay)) do \n        # some expensive calculation\n        result = 10       \n    end\nend\n\nstop_all_task(agent, t)\nwait_for_all_tasks(agent)","category":"page"},{"location":"scheduling/","page":"Scheduling","title":"Scheduling","text":"Finally, stop_and_wait_for_all_tasks is a convenience methods combining both stop_all_tasks and wait_for_all_tasks.","category":"page"},{"location":"scheduling/#.-Scheduler","page":"Scheduling","title":"3. Scheduler","text":"","category":"section"},{"location":"scheduling/","page":"Scheduling","title":"Scheduling","text":"The Scheduler type is an internal structure that holds a collection of tasks to be scheduled and executed. Every agent contains such a scheduler struct by default and implements methods for convenient delegation.","category":"page"},{"location":"scheduling/#Structure","page":"Scheduling","title":"Structure","text":"","category":"section"},{"location":"scheduling/","page":"Scheduling","title":"Scheduling","text":"struct Scheduler\n    tasks::Vector{Task}\nend","category":"page"},{"location":"scheduling/#.-Functions","page":"Scheduling","title":"4. Functions","text":"","category":"section"},{"location":"scheduling/#execute_task","page":"Scheduling","title":"execute_task","text":"","category":"section"},{"location":"scheduling/","page":"Scheduling","title":"Scheduling","text":"The execute_task function executes a task with a specific TaskData.","category":"page"},{"location":"scheduling/#Signatures","page":"Scheduling","title":"Signatures","text":"","category":"section"},{"location":"scheduling/","page":"Scheduling","title":"Scheduling","text":"execute_task(f::Function, data::PeriodicTaskData)\nexecute_task(f::Function, data::InstantTaskData)\nexecute_task(f::Function, data::DateTimeTaskData)\nexecute_task(f::Function, data::AwaitableTaskData)\nexecute_task(f::Function, data::ConditionalTaskData)","category":"page"},{"location":"scheduling/#schedule","page":"Scheduling","title":"schedule","text":"","category":"section"},{"location":"scheduling/","page":"Scheduling","title":"Scheduling","text":"The schedule function adds a task to the scheduler with the specified TaskData and scheduling type.","category":"page"},{"location":"scheduling/#Signature","page":"Scheduling","title":"Signature","text":"","category":"section"},{"location":"scheduling/","page":"Scheduling","title":"Scheduling","text":"schedule(f::Function, scheduler::Union{Scheduler,Agent}, data::TaskData, scheduling_type::SchedulingType=ASYNC)","category":"page"},{"location":"scheduling/#wait*for*all_tasks","page":"Scheduling","title":"waitforall_tasks","text":"","category":"section"},{"location":"scheduling/","page":"Scheduling","title":"Scheduling","text":"The wait_for_all_tasks function waits for all the scheduled tasks in the provided scheduler to complete.","category":"page"},{"location":"scheduling/#Signature-2","page":"Scheduling","title":"Signature","text":"","category":"section"},{"location":"scheduling/","page":"Scheduling","title":"Scheduling","text":"wait_for_all_tasks(scheduler::Scheduler)","category":"page"},{"location":"scheduling/#stop_task","page":"Scheduling","title":"stop_task","text":"","category":"section"},{"location":"scheduling/","page":"Scheduling","title":"Scheduling","text":"The stop_task function sends the stop signal to a task t. This will result in its completion once the next execution cycle is finished. If t is not stopable this will output a warning.","category":"page"},{"location":"scheduling/#Signature-3","page":"Scheduling","title":"Signature","text":"","category":"section"},{"location":"scheduling/","page":"Scheduling","title":"Scheduling","text":"stop_task(scheduler::Scheduler, t::Task)","category":"page"},{"location":"scheduling/#stop*all*tasks","page":"Scheduling","title":"stopalltasks","text":"","category":"section"},{"location":"scheduling/","page":"Scheduling","title":"Scheduling","text":"The stop_all_tasks function sends the stop signal to all stopable tasks. This will result in their completion once the next execution cycle is finished.","category":"page"},{"location":"scheduling/#Signature-4","page":"Scheduling","title":"Signature","text":"","category":"section"},{"location":"scheduling/","page":"Scheduling","title":"Scheduling","text":"stop_all_tasks(scheduler::Scheduler)","category":"page"},{"location":"scheduling/#stop*and*wait*for*all_tasks","page":"Scheduling","title":"stopandwaitforall_tasks","text":"","category":"section"},{"location":"scheduling/","page":"Scheduling","title":"Scheduling","text":"The stop_and_wait_for_all_tasks function sends the stop signal to all stopable tasks. It then waits for all scheduled tasks to finish.","category":"page"},{"location":"scheduling/#Signature-5","page":"Scheduling","title":"Signature","text":"","category":"section"},{"location":"scheduling/","page":"Scheduling","title":"Scheduling","text":"stop_and_wait_for_all_tasks(scheduler::Scheduler)","category":"page"},{"location":"encode_decode/#Mango.jl-Encoding-and-Decoding-(codec)-Feature-User-Documentation","page":"Codecs","title":"Mango.jl Encoding and Decoding (codec) Feature User Documentation","text":"","category":"section"},{"location":"encode_decode/","page":"Codecs","title":"Codecs","text":"Codecs provide functions for serializing and deserializing data to Mango containers. They use LightBSON.jl as their backend.","category":"page"},{"location":"encode_decode/","page":"Codecs","title":"Codecs","text":"As of now, the encode and decode functions forward their inputs directly to bson_read and bson_write. For most cases, we expect to pass messages as OrderedDict{String, Any}. We also forward an optional type field when decoding that is passed to bson_write to make use of the existing type-casting functionality here. For full information on what will work with this type of inference, we refer to the LightBSON.jl documentation.","category":"page"},{"location":"encode_decode/","page":"Codecs","title":"Codecs","text":"For future versions, we plan on adding a more convenient (but likely slower) type inference variant of the codec that saves necessary type information when encoding and iterates the output data while decoding to restore it exactly as it was before encoding (including type information).","category":"page"},{"location":"agent/#Agents","page":"Agents","title":"Agents","text":"","category":"section"},{"location":"agent/","page":"Agents","title":"Agents","text":"Agents are autonomous entities that can perceive their environment, make decisions, and interact with other agents and the system they inhabit. They are the building blocks of Mango.jl, representing the individual entities or actors within a larger system.","category":"page"},{"location":"agent/#.-Agent-Definition-with-@agent-Macro","page":"Agents","title":"1. Agent Definition with @agent Macro","text":"","category":"section"},{"location":"agent/","page":"Agents","title":"Agents","text":"To define an agent the @agent macro can be used. It simplifies the process of defining an agent struct and automatically adds necessary baseline fields. Here's how you can define an agent:","category":"page"},{"location":"agent/","page":"Agents","title":"Agents","text":"using Mango\n\n# Define your agent struct using @agent macro\n@agent struct MyAgent\n    my_own_field::String\nend\n\n# Create an instance of the agent\nmy_agent = MyAgent(\"MyValue\")","category":"page"},{"location":"agent/","page":"Agents","title":"Agents","text":"The @agent macro adds the baseline fields listed in the table below. You can initialize the agent with exclusive fields like my_own_field in the example.","category":"page"},{"location":"agent/","page":"Agents","title":"Agents","text":"Field Description Usable?\naid The id of the agent Yes with aid(agent)!\ncontext Holds the reference to the container to send messages. Generally not recommended, use the convenience methods defined on the Agent type.\nscheduler The scheduler of the agent Generally not recommended, use the convenience methods defined on the Agent type.\nlock The agent lock to ensure only one message is handled per time. Internal use only!\nrole_handler Contains the roles and handles their interactions Internal use only!","category":"page"},{"location":"agent/#.-Role-Management","page":"Agents","title":"2. Role Management","text":"","category":"section"},{"location":"agent/","page":"Agents","title":"Agents","text":"Agents can have multiple roles associated with them. Roles can be added using the add function, allowing the agent to interact with its environment based on different roles. Here's how you can add roles to an agent:","category":"page"},{"location":"agent/","page":"Agents","title":"Agents","text":"using Mango\n\n# Define your role struct using @role macro\n@role struct MyRole\n    my_own_field::String\nend\n\n# Assume you have already defined roles using Mango.AgentRole module\nrole1 = MyRole(\"Role1\")\nrole2 = MyRole(\"Role2\")\n\n# Define your agent struct using @agent macro\n@agent struct MyAgent\n    my_own_field::String\nend\n\n# Create an instance of the agent\nmy_agent = MyAgent(\"MyValue\")\n\n# Add roles to the agent\nadd(my_agent, role1)\nadd(my_agent, role2)\n\n# Now you can interact with the roles as needed","category":"page"},{"location":"agent/","page":"Agents","title":"Agents","text":"As this can be clunky at some time, there is the possibility to create an agent using only roles and add it to the container using add_agent_composed_of.","category":"page"},{"location":"agent/","page":"Agents","title":"Agents","text":"# internally an empty agent definition is used, the roles are added and the agent\n# is added to the given container\ncreated_agent = add_agent_composed_of(your_container, RoleA(), RoleB(), RoleC())","category":"page"},{"location":"agent/","page":"Agents","title":"Agents","text":"For more information on roles, take a look at Role definition","category":"page"},{"location":"agent/#.-Message-Handling","page":"Agents","title":"3. Message Handling","text":"","category":"section"},{"location":"agent/","page":"Agents","title":"Agents","text":"Agents and Roles can handle incoming messages through the handle_message function. By default, it does nothing, but you can override it to define message-specific behavior. You can also add custom message handlers for specific roles using the subscribe_message function. Here's how to handle messages:","category":"page"},{"location":"agent/","page":"Agents","title":"Agents","text":"using Mango\n\n# Define your agent struct using @agent macro\n@agent struct MyAgent\n    my_own_field::String\nend\n@role struct MyRole\n    my_own_field::String\nend\n\n# Override the default handle_message function for custom behavior\nfunction handle_message(agent::MyAgent, message::Any, meta::Any)\n    println(\"Received message @agent: \", message)\nend\n# Override the default handle_message function for custom behavior\nfunction handle_message(role::MyRole, message::Any, meta::Any)\n    println(\"Received message @role: \", message)\nend","category":"page"},{"location":"agent/","page":"Agents","title":"Agents","text":"Besides the ability to handle messages, there also must be a possibility to send messages. This is implemented using the send_message function, defined on roles and agents.","category":"page"},{"location":"agent/","page":"Agents","title":"Agents","text":"using Mango\n\n# Define your agent struct using @agent macro\n@agent struct MyAgent\n    my_own_field::String\nend\n@role struct MyRole\n    my_own_field::String\nend\n\nagent = MyAgent(\"\")\nrole = MyAgent(\"\")\n\nsend_message(agent, \"Message\", AgentAddress(\"receiver_id\", \"receiver_addr\", \"optional tracking id\"))\nsend_message(role, \"Message\", AgentAddress(\"receiver_id\", \"receiver_addr\", \"optional tracking id\"))","category":"page"},{"location":"agent/","page":"Agents","title":"Agents","text":"Further, there are several specialized methods for sending messages, (1) send_tracked_message, (2) send_and_handle_answer, (3) reply_to, (4) forward_to.","category":"page"},{"location":"agent/","page":"Agents","title":"Agents","text":"(1) This function can be used to send a message with an automatically generated tracking id (uuid1) and it also accepts a response handler, which will     automatically be called when a response arrives to the tracked message (care to include the tracking id when responding or just use reply_to). (2) Variant of (1) which requires a response handler and enables the usage of the do syntax (see following code snippet). (3) Convenience function to respond to a received message without the need to create the AgentAddress by yourself. (4) Convenience function to forward messages to another agent. This function will set the approriate fields in the meta container to identify that a message has been forwarded and from which address it has been forwarded.","category":"page"},{"location":"agent/","page":"Agents","title":"Agents","text":"agent1 = MyAgent(\"\")\nagent2 = MyAgent(\"\")\nagent3 = MyAgent(\"\")\n\nfunction handle_message(agent::MyAgent, message::Any, meta::Any)\n    # agent 2\n    reply_to(agent, \"Hello Agent, this is a response\", meta) # (3)\nend\nfunction handle_response(agent::MyAgent, message::Any, meta::Any)\n    # agent 1\n    forward_to(agent, \"Forwarded message\", address(agent3), meta) # (4)\nend\n\nsend_tracked_message(agent1, \"Hello Agent, this is a tracked message\", AgentAddress(aid=agent2.aid); response_handler=handle_response) # (1)\nsend_and_handle_answer(agent1, \"Hello Agent, this is a different tracked message\", AgentAddress(aid=agent2.aid)) do agent, message, meta # (2)\n    # agent 1\nend","category":"page"},{"location":"agent/","page":"Agents","title":"Agents","text":"There is also a possibility to enable automatic forwarding with adding so-called forwarding rules. For this you can use the function add_forwarding_rule(agent, from, to, forward_replies). To delete these rules the function delete_forwarding_rule(agent, from, to=nothing) exists.","category":"page"},{"location":"agent/#.-Task-Scheduling","page":"Agents","title":"4. Task Scheduling","text":"","category":"section"},{"location":"agent/","page":"Agents","title":"Agents","text":"Agents can schedule tasks using the schedule function, which delegates to the Mango.schedule function. You can wait for all scheduled tasks to be completed using wait_for_all_tasks. Here's how to schedule tasks:","category":"page"},{"location":"agent/","page":"Agents","title":"Agents","text":"using Mango\n\n# Define your agent struct using @agent macro\n@agent struct MyAgent\n    my_own_field::String\nend\n\n# Create an instance of the agent\nmy_agent = MyAgent(\"MyValue\")\n\n# Schedule a task for the agent\nschedule(my_task_function, my_agent, PeriodicTaskData(5.0)) # Schedule a task to run every 5 seconds\n\n# Wait for all scheduled tasks to complete\nwait_for_all_tasks(my_agent)","category":"page"},{"location":"legals/#Legals","page":"Legals","title":"Legals","text":"","category":"section"},{"location":"legals/","page":"Legals","title":"Legals","text":"Address","category":"page"},{"location":"legals/","page":"Legals","title":"Legals","text":"OFFIS e. V.   Escherweg 2   26121 Oldenburg   Germany   Phone +49 441 9722-0   Fax +49 441 9722-102   Email: institut [ A T ] offis.de   Internet: www.offis.de  ","category":"page"},{"location":"legals/","page":"Legals","title":"Legals","text":"Board Members","category":"page"},{"location":"legals/","page":"Legals","title":"Legals","text":"Prof. Dr. Sebastian Lehnhoff (Chairman)   Prof. Dr. techn. Susanne Boll-Westermann   Prof. Dr.-Ing. Andreas Hein   Prof. Dr.-Ing. Astrid Nieße","category":"page"},{"location":"legals/","page":"Legals","title":"Legals","text":"Register Court","category":"page"},{"location":"legals/","page":"Legals","title":"Legals","text":"Amtsgericht Oldenburg   Registernumber VR 1956","category":"page"},{"location":"legals/","page":"Legals","title":"Legals","text":"VAT Identification Number","category":"page"},{"location":"legals/","page":"Legals","title":"Legals","text":"DE 811582102","category":"page"},{"location":"legals/","page":"Legals","title":"Legals","text":"Responsible in the sense of press law","category":"page"},{"location":"legals/","page":"Legals","title":"Legals","text":"Dr. Ing. Jürgen Meister (Director)   OFFIS e.V.   Escherweg 2   26121 Oldenburg  ","category":"page"},{"location":"legals/","page":"Legals","title":"Legals","text":"Disclaimer","category":"page"},{"location":"legals/","page":"Legals","title":"Legals","text":"Despite careful control OFFIS assumes no liability for the content of external links. The operators of such a website are solely responsible for its content. At the time of linking the concerned sites were checked for possible violations of law. Illegal contents were not identifiable at that time. A permanent control of the linked pages is not reasonable without specific indications of a violation. Upon notification of violations, OFFIS will remove such links immediately.","category":"page"},{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#Express","page":"API","title":"Express","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"This part contains basic convenience functions for creating and running Mango.jl simulations. ","category":"page"},{"location":"api/","page":"API","title":"API","text":"Modules = [Mango]\nPrivate = false\nPages = [\"express/api.jl\"]","category":"page"},{"location":"api/#Mango.activate-Union{Tuple{T}, Tuple{Function, Vector{T}}} where T<:ContainerInterface","page":"API","title":"Mango.activate","text":"activate(runnable, container_list)\n\nActvate the container(s), which includes starting the containers and shutting them down after the runnable has been executed. \n\nIn most cases the runnable will execute code, which starts some process  (e.g. some distributed negotiation) in the system to define the objective of the agent system.\n\nGenerally this function is a convenience function and is equivalent to starting all containers  in the list, executing the code represented by runnable and shuting down the container again. Further, this function will handle errors occuring while running the runnable and ensure the containers are shutting down.\n\nExamples\n\nactivate(your_containers) do \n   # Send the first message to start the system\n   send_message(defined_agent, \"Starting somethin\", address(other_defined_agent))\n\n   # wait some time\n   wait(some_stopping_condition)\nend\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.add_agent_composed_of-Tuple{ContainerInterface, Vararg{Role}}","page":"API","title":"Mango.add_agent_composed_of","text":"add_agent_composed_of(container, roles...)\n\nCreate an agent which is composed of the given roles roles... and register the agent  to the container. \n\nThe agent struct used is an empty struct, it is only used as a container for the roles. The created agent will be returned by the function.\n\nExamples\n\nagent = add_agent_composed_of(your_container, RoleA(), RoleB(), RoleC())\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.create_mqtt_container-Tuple{String, Int64, String}","page":"API","title":"Mango.create_mqtt_container","text":"create_mqtt_container(host, port, client_id; codec=nothing)\n\nCreate a container using an MQTT protocol. \n\nThe host is expected to be the IP-adress of the broker, port is the port of the broker,  the client_id is the id of the client which will be created and connected to the broker.  Optionally you can also provide a codec as tuple of functions (first encode, second decode, see  encode and decode).\n\nExamples\n\nagent = create_mqtt_container(\"127.0.0.1\", 5555, \"MyClient\")\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.create_tcp_container-Tuple{String, Int64}","page":"API","title":"Mango.create_tcp_container","text":"create_tcp_container(host, port; codec=nothing)\n\nCreate a container using an TCP protocol. \n\nThe host is expected to be the IP-adress to bind on, port is the port to bind on. Optionally you  can also provide a codec as tuple of functions (first encode, second decode, see  encode and decode).\n\nExamples\n\nagent = create_mqtt_container(\"127.0.0.1\", 5555, \"MyClient\")\n\n\n\n\n\n","category":"method"},{"location":"api/#Agent","page":"API","title":"Agent","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Here, all exposed API for the agent structs created with @agent is listed. ","category":"page"},{"location":"api/","page":"API","title":"API","text":"Modules = [Mango]\nPrivate = false\nPages = [\"agent/api.jl\", \"agent/core.jl\", \"agent/role.jl\"]\nOrder   = [:macro, :function, :constant, :type, :module]","category":"page"},{"location":"api/#Mango.address-Tuple{Mango.AgentInterface}","page":"API","title":"Mango.address","text":"Used internally by the role to get the AgentAddress\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.aid-Tuple{Mango.AgentInterface}","page":"API","title":"Mango.aid","text":"Used internally by the role to get the AID\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.forward_to-Tuple{Mango.AgentInterface, Any, Address, AbstractDict}","page":"API","title":"Mango.forward_to","text":"API Definition for forwarding messages to other agents. \n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.reply_to-Tuple{Mango.AgentInterface, Any, AbstractDict}","page":"API","title":"Mango.reply_to","text":"API Definition for directly replying to a message\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.send_and_handle_answer-Tuple{Function, Mango.AgentInterface, Any, Address}","page":"API","title":"Mango.send_and_handle_answer","text":"API Definition for sending tracked message with required response handler\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.send_message-Tuple{Mango.AgentInterface, Any, Address}","page":"API","title":"Mango.send_message","text":"API Definition for the role context\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.Address","page":"API","title":"Mango.Address","text":"Supertype of all address types\n\n\n\n\n\n","category":"type"},{"location":"api/#Mango.Agent","page":"API","title":"Mango.Agent","text":"Base-type for all agents in mango. Generally exists for type-safety and default implementations across all agents.\n\n\n\n\n\n","category":"type"},{"location":"api/#Mango.@agent-Tuple{Any}","page":"API","title":"Mango.@agent","text":"Macro for defining an agent struct. Expects a struct definition as argument.\n\nThe macro does 3 things:\n\nIt adds all baseline fields, defined in AGENTBASELINEFIELDS (the agent context context, the role handler role_handler, and the aid)\nIt adds the supertype Agent to the given struct.\nIt defines a default constructor, which assigns all baseline fields to predefined default values. As a result you can (and should) create  an agent using only the exclusive fields.\n\nFor example the usage could like this.\n\n@agent struct MyAgent\n\tmy_own_field::String\nend\n\n# results in\n\nmutable struct MyAgent <: Agent\n\t# baseline fields...\n\tmy_own_field::String\nend\nMyAgent(my_own_field) = MyAgent(baseline fields defaults..., my_own_field)\n\n# so youl would construct your agent like this\n\nmy_agent = MyAgent(\"own value\")\n\n\n\n\n\n","category":"macro"},{"location":"api/#Base.schedule-Tuple{Function, Agent, TaskData}","page":"API","title":"Base.schedule","text":"Delegates to the scheduler Scheduler\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.add-Tuple{Agent, Role}","page":"API","title":"Mango.add","text":"Add a role to the agent. This will add the role to the internal RoleHandler of the agent and it will bind the RoleContext to the role, which enables the role to interact with its environment.\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.add_forwarding_rule-Tuple{Agent, AgentAddress, AgentAddress, Bool}","page":"API","title":"Mango.add_forwarding_rule","text":"Add a rule for message forwarding.\n\nAfter calling the agent will auto-forward every message coming from from_addr to to_address. If forwardreplies is set, all replies from `toaddressare forwarded back tofrom_addr`.\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.add_service!-Tuple{Agent, Any}","page":"API","title":"Mango.add_service!","text":"add_service!(agent, service)\n\nAdd a service to the agent. Every service can exists exactly one time (stored by type).\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.address-Tuple{Agent}","page":"API","title":"Mango.address","text":"Shorter Alias\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.aid-Tuple{Agent}","page":"API","title":"Mango.aid","text":"Returns the agent id of the agent.\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.delete_forwarding_rule-Tuple{Agent, AgentAddress, Union{Nothing, AgentAddress}}","page":"API","title":"Mango.delete_forwarding_rule","text":"Delete an added forwarding rule. If to_address is not set, all rules are removed matching from_addr. If it set, both addresses need to match.\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.forward_to-Tuple{Agent, Any, AgentAddress, AbstractDict}","page":"API","title":"Mango.forward_to","text":"forward_to(agent, content, forward_to_address, received_meta; kwargs...)\n\nForward the message to a specific agent using the metadata received on handling the message. This method essentially simply calls send_message on the input given, but also adds and fills the correct metadata fields to mark the message as forwarded. \n\nFor this the following meta data is set. 'forwarded=true', 'forwardedfromaddress=address of the original sender', 'forwardedfromid=id of the original sender'\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.handle_message-Tuple{Agent, Any, Any}","page":"API","title":"Mango.handle_message","text":"Defines a function for an agent, which will be called when a message is dispatched to the agent. This methods will be called with any arriving message (according to the multiple dispatch of julia).\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.on_ready-Tuple{Agent}","page":"API","title":"Mango.on_ready","text":"Lifecycle Hook-in function called when the agent system as a whole is ready, the  hook-in has to be manually activated using notify_ready(container::Container)\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.on_start-Tuple{Agent}","page":"API","title":"Mango.on_start","text":"Lifecycle Hook-in function called when the container of the agent has been started, depending on the container type it may not be called (if there is no start at all,  f.e. the simulation container)\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.reply_to-Tuple{Agent, Any, AbstractDict}","page":"API","title":"Mango.reply_to","text":"Convenience method to reply to a received message using the meta the agent received. This reduces the regular sendmessage as response `sendmessage(agent, \"Pong\", AgentAddress(aid=meta[\"senderid\"], address=meta[\"senderaddr\"]))toreply_to(agent, \"Pong\", meta)`\n\nFurthermore it guarantees that agent address (including the tracking id, which is part of the address!) is correctly passed to the mango container.\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.roles-Tuple{Agent}","page":"API","title":"Mango.roles","text":"Return all roles of the given agent\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.send_and_handle_answer-Tuple{Function, Agent, Any, AgentAddress}","page":"API","title":"Mango.send_and_handle_answer","text":"Convenience method for sending tracked messages with response handler to the answer.\n\nSends a tracked message with a required response_handler to enable to use the syntax\n\nsend_and_handle_answer(...) do agent, message, meta\n\t# handle the answer\nend\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.send_message-Tuple{Agent, Any, AgentAddress}","page":"API","title":"Mango.send_message","text":"Send a message using the context to the agent with the receiver id receiver_id at the address receiver_addr.  This method will always set a sender_id. Additionally, further keyword arguments can be defines to fill the  internal meta data of the message.\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.send_tracked_message-Tuple{Agent, Any, AgentAddress}","page":"API","title":"Mango.send_tracked_message","text":"Send a message using the context to the agent with the receiver id receiver_id at the address receiver_addr.  This method will always set a sender_id. Additionally, further keyword arguments can be defines to fill the  internal meta data of the message.\n\nFurthermore, message sent with this method will be wrapped in a data object which annotates the message with a  transactional id, to be able to track this specific agent discussion. For this it is possible to define a response_handler, to which a functin can be assigned, which handles the answer to this message call. To continue the conversation the transaction id has to be tr by kwargs in the response handler \n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.service_of_type-Union{Tuple{T}, Tuple{Agent, Type{T}}, Tuple{Agent, Type{T}, Union{Nothing, T}}} where T","page":"API","title":"Mango.service_of_type","text":"service_of_type(agent, type::Type{T}, default=nothing)::Union{T,Nothing} where {T}\n\nReturn the current agent service of the type type. \n\nIf a default is set, this default service will be added to the agent as service of te type `type. The function is especially useful if you want to extend the functionality of the agent without having to change the internals of the agent, as this functions enables the user to add  arbitrary data to the agent on which functions can be defined.\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.services-Tuple{Agent}","page":"API","title":"Mango.services","text":"services(agent)::Dict{DataType,Any}\n\nReturn a list of services, which were added to the agent.\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.shutdown-Tuple{Agent}","page":"API","title":"Mango.shutdown","text":"Will be called on shutdown of the container, in which the agent is living\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.stop_all_tasks-Tuple{Agent}","page":"API","title":"Mango.stop_all_tasks","text":"Delegates to the scheduler Scheduler\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.stop_and_wait_for_all_tasks-Tuple{Agent}","page":"API","title":"Mango.stop_and_wait_for_all_tasks","text":"Delegates to the scheduler Scheduler\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.stop_task-Tuple{Agent, Task}","page":"API","title":"Mango.stop_task","text":"Delegates to the scheduler Scheduler\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.wait_for_all_tasks-Tuple{Agent}","page":"API","title":"Mango.wait_for_all_tasks","text":"Delegates to the scheduler Scheduler\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.AgentContext","page":"API","title":"Mango.AgentContext","text":"Context of the agent. Represents the environment for the specific agent. Therefore it includes a  connection to the container, including all functions used for interacting with the environment for the agent.\n\n\n\n\n\n","category":"type"},{"location":"api/#Mango.AgentRoleHandler","page":"API","title":"Mango.AgentRoleHandler","text":"Internal data regarding the roles.\n\n\n\n\n\n","category":"type"},{"location":"api/#Mango.@role-Tuple{Any}","page":"API","title":"Mango.@role","text":"Macro for defining a role struct. Expects a struct definition as argument.\n\nThe macro does 3 things:\n\nIt adds all baseline fields, defined in ROLEBASELINEFIELDS (the role context)\nIt adds the supertype Role to the given struct.\nIt defines a default constructor, which assigns all baseline fields to predefined default values. As a result you can (and should) create  a role using only the exclusive fields.\n\nFor example the usage could like this.\n\n@role struct MyRole\n\tmy_own_field::String\nend\n\n# results in\n\nmutable struct MyRole <: Agent\n\t# baseline fields...\n\tmy_own_field::String\nend\nMyRole(my_own_field) = MyRole(baseline fields defaults..., my_own_field)\n\n# so youl would construct your role like this\n\nmy_roel = MyRole(\"own value\")\n\n\n\n\n\n","category":"macro"},{"location":"api/#Mango.@shared-Tuple{Any}","page":"API","title":"Mango.@shared","text":"Mark the field as shared across roles, this will implicitly \n\n\n\n\n\n","category":"macro"},{"location":"api/#Base.schedule-Tuple{Function, Role, TaskData}","page":"API","title":"Base.schedule","text":"Delegates to the scheduler Scheduler\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.address-Tuple{Role}","page":"API","title":"Mango.address","text":"Get AgentAddress of the parent agent\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.aid-Tuple{Role}","page":"API","title":"Mango.aid","text":"Get AID of the parent agent\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.bind_context-Tuple{Role, RoleContext}","page":"API","title":"Mango.bind_context","text":"Internal function, used to initialize to role for a specified agent\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.emit_event-Tuple{Role, Any}","page":"API","title":"Mango.emit_event","text":"Emit an event to their subscriber\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.get_model-Tuple{Role, DataType}","page":"API","title":"Mango.get_model","text":"Get a shared model from the pool. If the model does not exist yet, it will be created. Only types with default constructor are allowed!\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.handle_event-Tuple{Role, Role, Any}","page":"API","title":"Mango.handle_event","text":"Default function for arriving events, which get dispatched to the role.\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.handle_message-Tuple{Role, Any, Any}","page":"API","title":"Mango.handle_message","text":"Default function for arriving messages, which get dispatched to the role. This function will be called for every message arriving at the agent of the role.\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.on_ready-Tuple{Role}","page":"API","title":"Mango.on_ready","text":"Lifecycle Hook-in function called when the agent system as a whole is ready, the  hook-in has to be manually activated using notify_ready(container::Container)\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.on_start-Tuple{Role}","page":"API","title":"Mango.on_start","text":"Lifecycle Hook-in function called when the container of the agent has been started, depending on the container type it may not be called (if there is no start at all,  f.e. the simulation container)\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.setup-Tuple{Role}","page":"API","title":"Mango.setup","text":"Hook-in function to setup the role, after it has been added to its agent.\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.shutdown-Tuple{Role}","page":"API","title":"Mango.shutdown","text":"Hook-in function, which will be called on shutdown of the roles agent.\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.subscribe_event-Tuple{Role, Any, Any, Function}","page":"API","title":"Mango.subscribe_event","text":"Subscribe to specific types of events.\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.subscribe_event-Tuple{Role, Any, Any}","page":"API","title":"Mango.subscribe_event","text":"Subscribe to specific types of events.\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.subscribe_message-Tuple{Role, Function, Function}","page":"API","title":"Mango.subscribe_message","text":"Subscribe a message handler function (it need to have the signature (role, message, meta)) to the message dispatching. This handler function will be called everytime the given condition function (message, meta -> boolean) evaluates to true when a message arrives at the roles agent.\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.subscribe_send-Tuple{Role, Function}","page":"API","title":"Mango.subscribe_send","text":"Subscribe a sendmessage hook in function (signature, (role, content, receiverid, receiver_addr; kwargs...)) to the message sending. The hook in function will be called every time a message is sent by the agent.\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.Role","page":"API","title":"Mango.Role","text":"Defines the type Role, which is the common base types for all roles in mango.\n\nA Role is a bundled behavivor of an agent, which shall fulfill exactly one  responsibility of an agent - the role. Technically speaking roles are the way to implement the composition pattern for agents, and to introduce modular archetypes, which shall be reused in different contexts. \n\n\n\n\n\n","category":"type"},{"location":"api/#Mango.RoleContext","page":"API","title":"Mango.RoleContext","text":"The RoleContext connects the role with its environment, which is mostly its agents. This is abstracted using the AgentInterface.\n\n\n\n\n\n","category":"type"},{"location":"api/#Container","page":"API","title":"Container","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"This part contains the API related to the container construction, access and management.","category":"page"},{"location":"api/","page":"API","title":"API","text":"Modules = [Mango]\nPrivate = false\nPages = [\"container/api.jl\", \"container/core.jl\", \"container/mqtt.jl\", \"container/protocol.jl\", \"container/simulation.jl\", \"container/tcp.jl\"]","category":"page"},{"location":"api/#Mango.AgentAddress","page":"API","title":"Mango.AgentAddress","text":"Default AgentAddress base type, where the agent identifier is based on the container created agent id (aid). Used with the TCP protocol.\n\n\n\n\n\n","category":"type"},{"location":"api/#Mango.ContainerInterface","page":"API","title":"Mango.ContainerInterface","text":"Supertype of every container implementation. This acts as an interface to be used by the agents in their contexts.\n\n\n\n\n\n","category":"type"},{"location":"api/#Mango.MQTTAddress","page":"API","title":"Mango.MQTTAddress","text":"Connection information for an MQTT topic on a given broker.  Used with the MQTT protocol. \n\n\n\n\n\n","category":"type"},{"location":"api/#Mango.protocol_addr-Tuple{ContainerInterface}","page":"API","title":"Mango.protocol_addr","text":"Used by the agent to get the protocol addr part\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.send_message","page":"API","title":"Mango.send_message","text":"Send a message message using the given containercontainer` to the given address. Additionally, further keyword arguments can be defines to fill the internal meta data of the message.\n\nThis only defines the function API, the actual implementation is done in the core container module.\n\n\n\n\n\n","category":"function"},{"location":"api/#Mango.Container","page":"API","title":"Mango.Container","text":"The default container struct, representing the container as actor. The container is implemented by composition. This means the container consists of different implementations of base types, which define the behavior of the container itself. That being said, the same container generally able to send messages via different protocols using different codecs.\n\n\n\n\n\n","category":"type"},{"location":"api/#Mango.notify_ready-Tuple{Container}","page":"API","title":"Mango.notify_ready","text":"Mark the agent system as ready, needs to be detected and called manually!\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.protocol_addr-Tuple{Container}","page":"API","title":"Mango.protocol_addr","text":"Get protocol addr part\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.register","page":"API","title":"Mango.register","text":"Register an agent given the target container container. While registering an aid will be generated and assigned to the agent.\n\nThis function will add the agent to the internal list of the container and will from then on be controlled by the container regarding the messaging activities. That means the container acts as the gateway of the agent defining its possible way to retrieve  messages.\n\nArgs\n\nsuggested_aid: you can provide an aid yourself. The container will always use that aid \tif possible\n\nReturns\n\nThe actually used aid will be returned.\n\n\n\n\n\n","category":"function"},{"location":"api/#Mango.send_message-2","page":"API","title":"Mango.send_message","text":"Send a message message with using the given container container to the agent with the receiver id receiver_id. The receivers address  is used by the chosen protocol to appropriatley route the message to external participants. To specifiy further meta data of the message kwargs should be used.\n\nReturns\n\nTrue if the message has been sent successfully, false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"api/#Mango.send_message-Tuple{Container, Any, MQTTAddress, Vararg{Any}}","page":"API","title":"Mango.send_message","text":"Send message version for MQTT topics.  Note that there is no local message forwarding here because messages always get pushed to a broker and are not directly addressed to an agennt.\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.shutdown-Tuple{Container}","page":"API","title":"Mango.shutdown","text":"Shut down the container. It is always necessary to call it for freeing bound resources\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.start-Tuple{Container}","page":"API","title":"Mango.start","text":"Starts the container and initialized all its components. After the call the container start to act as the communication layer.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.close-Tuple{MQTTProtocol}","page":"API","title":"Base.close","text":"Disconnect the client from the broker and stop the message loop.\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.id-Tuple{MQTTProtocol}","page":"API","title":"Mango.id","text":"Returns the namethe client is registered with at its broker.\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.init-Tuple{MQTTProtocol, Function, Function}","page":"API","title":"Mango.init","text":"Initialize the Mosquitto looping task. This checks for incoming messages and  forwards their content to the container.\n\nReturns\n\nCreated Tasks\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.notify_register-Tuple{MQTTProtocol, String}","page":"API","title":"Mango.notify_register","text":"Notify the client that a new agent has been registered. Registrations expects a kwarg topics  to subscribe the agent to.  If any topic is not yet subscribed by the client subscribe is called for it.\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.send-Tuple{MQTTProtocol, String, Any}","page":"API","title":"Mango.send","text":"Send a message message to topic destination on the clients MQTT broker . \n\nReturns\n\nReturn value and message id from MQTT library.\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.subscribe-Tuple{MQTTProtocol, String}","page":"API","title":"Mango.subscribe","text":"Subscribe the MQTT client of the protocol to topic.\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.Protocol","page":"API","title":"Mango.Protocol","text":"Type for all implementations of protocols, acts like an interface. A protocol defines the way message are processed and especially sent and received  to an other peer. F.E. A protocol could be to send messages using a plain TCP connection, which would indicate that an internet address (host + port) is required for the communication.\n\nThe parameterized type T indicates type, which defines the address data of the receiver and sender.\n\nEvery protocol has to define two methods.\n\nsend: defines the behavior of the protocol when an agents sends a messages\ninit: defines the necessary steps to initialize (especially) the receiver loop and\n\n\t therefore accepts a stop check and a data handler function to indicate when the receiver should stop, \n\t respectively how to dispatch the received message to the correct agent\n\n\n\n\n\n","category":"type"},{"location":"api/#Mango.id-Union{Tuple{Protocol{T}}, Tuple{T}} where T","page":"API","title":"Mango.id","text":"Return the external identifier associated with the protocol (e.g. it could be the host+port, dns name, ...)\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.init-Union{Tuple{T}, Tuple{Protocol{T}, Function, Function}} where T","page":"API","title":"Mango.init","text":"Initialized the protocols internal loops (if exists). In most implementation this would mean that the receiver loop is started. To handle received messages the data_handler function can be passed (msg, sender) -> your handling code. \n\nTo control the lifetime of the loops a stop_check should be passed (() -> boolean). If the stop check is true the loops will  terminate. The exact behavior depends on the implementation though.\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.notify_register-Union{Tuple{T}, Tuple{Protocol{T}, String}} where T","page":"API","title":"Mango.notify_register","text":"Protocol specific updates called when a new agent is registered.\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.parse_id-Union{Tuple{T}, Tuple{Protocol{T}, Any}} where T","page":"API","title":"Mango.parse_id","text":"Parse different types to the correct type (if required). Should be implemented if the id type is not trivial.\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.send-Union{Tuple{T}, Tuple{Protocol{T}, T, Any}} where T","page":"API","title":"Mango.send","text":"Send the message message to the agent known by the adress destination. How the message is exactly handled is  determined by the protocol invoked. \n\nThe type of the destination has to match with the protocol. \n\nReturns\n\nThe function returns a boolean indicating whether the message was successfull sent\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.protocol_addr-Tuple{SimulationContainer}","page":"API","title":"Mango.protocol_addr","text":"Get protocol addr part\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.register-2","page":"API","title":"Mango.register","text":"Register an agent given the target container container. While registering an aid will be generated and assigned to the agent.\n\nThis function will add the agent to the internal list of the container and will from then on be controlled by the container regarding the messaging activities. That means the container acts as the gateway of the agent defining its possible way to retrieve  messages.\n\nArgs\n\nsuggested_aid: you can provide an aid yourself. The container will always use that aid \tif possible\n\nReturns\n\nThe actually used aid will be returned.\n\n\n\n\n\n","category":"function"},{"location":"api/#Mango.send_message-3","page":"API","title":"Mango.send_message","text":"Send a message message with using the given container container to the agent with the receiver id receiver_id. The receivers address  is used by the chosen protocol to appropriatley route the message to external participants. To specifiy further meta data of the message kwargs should be used.\n\nReturns\n\nTrue if the message has been sent successfully, false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"api/#Mango.shutdown-Tuple{SimulationContainer}","page":"API","title":"Mango.shutdown","text":"Shut down the container. It is always necessary to call it for freeing bound resources\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.close-Tuple{TCPProtocol}","page":"API","title":"Base.close","text":"Release all tcp resources\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.init-Tuple{TCPProtocol, Function, Function}","page":"API","title":"Mango.init","text":"Initialized the tcp protocol. This starts the receiver and stop loop. The receiver loop will call the data_handler with every incoming message. Further it provides as sender adress a InetAddr object. \n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.send-Tuple{TCPProtocol, Sockets.InetAddr, Vector{UInt8}}","page":"API","title":"Mango.send","text":"Send a message message over plain TCP using destination as destination address. The message has to be provided  as a form, which is writeable to an arbitrary IO-Stream.\n\nReturns\n\nReturn true if successfull.\n\n\n\n\n\n","category":"method"},{"location":"api/#Simulation","page":"API","title":"Simulation","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"In the following the APIs regarding the simulation container are listed.","category":"page"},{"location":"api/","page":"API","title":"API","text":"Modules = [Mango]\nPrivate = false\nPages = [\"simulation/communication.jl\", \"simulation/tasks.jl\"]","category":"page"},{"location":"api/#Scheduling","page":"API","title":"Scheduling","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"In the following the APIs for scheduling TaskData is listed.","category":"page"},{"location":"api/","page":"API","title":"API","text":"Modules = [Mango]\nPrivate = false\nPages = [\"util/scheduling.jl\"]","category":"page"},{"location":"api/#Topology","page":"API","title":"Topology","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"In the following the APIs for creating, aplying and using topologies is listed.","category":"page"},{"location":"api/","page":"API","title":"API","text":"Modules = [Mango]\nPrivate = false\nPages = [\"world/topology.jl\"]","category":"page"},{"location":"api/#Graphs.SimpleGraphs.add_edge!-Tuple{Topology, Int64, Int64}","page":"API","title":"Graphs.SimpleGraphs.add_edge!","text":"add_edge!(topology, node_id_from, node_id_to, directed=false)\n\nAdd an edge to the topology from node_id_from to node_id_to. If directed is true a directed edge is added, otherwise an undirected edge is added.\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.add!-Tuple{Mango.Node, Vararg{Agent}}","page":"API","title":"Mango.add!","text":"add!(node, agent::Agent...)\n\nAdd an agents to the node.\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.add_node!-Tuple{Topology, Vararg{Agent}}","page":"API","title":"Mango.add_node!","text":"add_node!(topology, agents::Agent...)::Int\n\nAdd a node to the topology with a list (or a single) of agents attached.\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.complete_topology-Tuple{Int64}","page":"API","title":"Mango.complete_topology","text":"complete_topology(number_of_nodes)\n\nCreate a fully-connected topology.\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.create_topology-Tuple{Function}","page":"API","title":"Mango.create_topology","text":"create_topology(create_runnable)::Topology\n\nCreate a topology using the create_runnable function which is a one-argument function with an initially empty topology as argument.\n\nExample\n\ntopology = create_topology() do topology\n    agent = register(container, TopologyAgent())\n    agent2 = register(container, TopologyAgent())\n    agent3 = register(container, TopologyAgent())\n    n1 = add_node!(topology, agent)\n    n2 = add_node!(topology, agent2)\n    n3 = add_node!(topology, agent3)\n    add_edge!(topology, n1, n2)\n    add_edge!(topology, n1, n3)\nend\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.cycle_topology-Tuple{Int64}","page":"API","title":"Mango.cycle_topology","text":"cycle_topology(number_of_nodes)\n\nCreate a cycle topology.\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.graph_topology-Tuple{Graphs.AbstractGraph}","page":"API","title":"Mango.graph_topology","text":"graph_topology(graph)\n\nCreate a topology based on a Graphs.jl (abstract) graph.\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.per_node-Tuple{Function, Topology}","page":"API","title":"Mango.per_node","text":"per_node(assign_runnable, topology)\n\nLoops over the nodes of the topology, calls assign_runnable on every node to enable the caller to populate the node. After the loop finished the neighborhoods are created and injected into the agent. \n\nExample\n\nper_node(topology) do node\n    add!(node, register(container, TopologyAgent()))\nend\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.star_topology-Tuple{Int64}","page":"API","title":"Mango.star_topology","text":"star_topology(number_of_nodes)\n\nCreate a star topology.\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango.topology_neighbors-Tuple{Agent}","page":"API","title":"Mango.topology_neighbors","text":"topology_neighbors(agent)\n\nRetrieve the neighbors of the agent, represented by their addresses. These vaues will be updated when a topology is applied using per_node or create_topology.\n\n\n\n\n\n","category":"method"},{"location":"api/#Encoding/Decoding","page":"API","title":"Encoding/Decoding","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"In the following the built-in functions for encoding and decoding messages are listed.","category":"page"},{"location":"api/","page":"API","title":"API","text":"Modules = [Mango]\nPrivate = false\nPages = [\"util/encode_decode.jl\"]","category":"page"},{"location":"simulation/#Simulation-Container","page":"Simulation","title":"Simulation Container","text":"","category":"section"},{"location":"simulation/","page":"Simulation","title":"Simulation","text":"The simulation container has the same role as the real-time container and therefore acts as communication and interaction interface to the environment. The simulation container maintains an interal simulation time and only executes tasks and delivers messages according to the requested step_sizes. It can be stepped in the continous mode or the discrete event mode. Further the container manages a common environment the agents can interact with as base structure for agent-based modeling simulations.","category":"page"},{"location":"simulation/#Create-and-stepping-a-simulation-container","page":"Simulation","title":"Create and stepping a simulation container","text":"","category":"section"},{"location":"simulation/","page":"Simulation","title":"Simulation","text":"To create a simulation container, it is advised to use create_simulation_container. This method will create a clock with the given simulation time and set default for the communication simulation and the general task simulation. In most cases the default task simulation will be what you desire. The communication simulation object (based on the abstract type CommunicationSimulation) is used to determine the delays of the messages in the simulation, while the task simulation determines the way the tasks are scheduled (within a time step, using parallelization etc.) in the simulation. ","category":"page"},{"location":"simulation/","page":"Simulation","title":"Simulation","text":"In the following example a simple simulation is executed.","category":"page"},{"location":"simulation/","page":"Simulation","title":"Simulation","text":"# Arbitrary agent definition\n@agent struct SimAgent\nend\n\n# Create a communication simulator, the simple communication simulator works with static delays between specific agents and a global default, here 0\ncomm_sim = SimpleCommunicationSimulation(default_delay_s=0)\n# Set the simulation time to an initial value\ncontainer = create_simulation_container(DateTime(Millisecond(1000)), communication_sim=comm_sim)\n\n# Creating agents and registering, no difference here to the real time container\nagent1 = SimAgent(0)\nagent2 = SimAgent(0)\nregister(container, agent1)\nregister(container, agent2)\n\n# Send a message from agent2 to agent1, the message will be written to a queue instead of processed by some protocol\nsend_message(agent2, \"Hello Friends, this is RSc!\", AgentAddress(aid=agent1.aid))\n\n# in this stepping call the message will be delivered and handled to/by the agent1  \n# step_size=1, if no size is specified the simulation will work as discrete event simulation, executing all tasks occurring on the next event time.\nstepping_result = step_simulation(container, 1)","category":"page"},{"location":"simulation/#Discrete-event-vs-continous-stepping","page":"Simulation","title":"Discrete event vs continous stepping","text":"","category":"section"},{"location":"simulation/","page":"Simulation","title":"Simulation","text":"Mango.jl support discrete event and continous stepping. Discrete event stepping means that no advance time is provided instead the simulation jumps to the next event time and executes every tasks, delivers every message scheduled at this next event time. For example, you set up a simultion in which three tasks are in the queue at the event times 1,1,3; then the next step would execute the first two, and the following would execute the last task (given no new tasks are created). With continous stepping the user has to provide a stepsize (in seconds), which will be used to execute every task until `simulationtime + step_size` ordered by the time of the individual tasks. It is also possible to mix both styles.","category":"page"},{"location":"simulation/","page":"Simulation","title":"Simulation","text":"# continous\nstepping_result = step_simulation(container, 1)\n# discrete event\nstepping_result = step_simulation(container)","category":"page"},{"location":"simulation/#Communication-simulation","page":"Simulation","title":"Communication simulation","text":"","category":"section"},{"location":"simulation/","page":"Simulation","title":"Simulation","text":"Mango.jl is generally designed to be extenable, this is also true for the usage of a communication simulator in a Mango.jl-Simulation. To use a custom communication simulator, you can simply set the keyword argument communication_sim to a struct of the abstract type CommunicationSimulation. To implement this type, you need to add a fitting method to Mango.calculate_communication::CommunicationSimulation, clock::Clock, messages::Vector{MessagePackage})::CommunicationSimulationResult. This method will then be called in the simulation loop at least once and repeatedly when new messages arrive and therefore a new state has to be determined.","category":"page"},{"location":"simulation/","page":"Simulation","title":"Simulation","text":"The default communication simulator is SimpleCommunicationSimulation. This simulator uses a default static delay together with a dictionary containing delays per link between individual agents.","category":"page"},{"location":"simulation/#Agent-based-modeling","page":"Simulation","title":"Agent-based modeling","text":"","category":"section"},{"location":"simulation/","page":"Simulation","title":"Simulation","text":"The simulation container can also be used for simple agent-based modeling simulations. In agent-based modeling, units (e.g. people, cars, ...) are modeled using agents and their interaction between these agents and further units in a common world/environment. To support this the simulation container provides on_step(agent::Agent, world::World, clock::Clock, step_size_s::Real) (also defined on Role). ","category":"page"},{"location":"simulation/","page":"Simulation","title":"Simulation","text":"The World can contain common objects to interact with and contains a Space struct which can define the type of world modeled (2D/3D/Graph/...). This struct also contains the positions of all agents. Currently there is only the Space2D implementation with simple cartesian coordinates. ","category":"page"},{"location":"simulation/","page":"Simulation","title":"Simulation","text":"Please note that Mango.jl focuses on agent-based control, agent-based communication and therefore currently does not provide much supporting implementations for complex agent-based modeling simulations.","category":"page"},{"location":"topology/#Topologies","page":"Topologies","title":"Topologies","text":"","category":"section"},{"location":"topology/","page":"Topologies","title":"Topologies","text":"In Mango.jl agents usually communicate with each other based on a topology. The topology determines which agent can communicate with which agent. To implement this, every agent has access to a neighborhood, which is the set of all agents it can communicate with. ","category":"page"},{"location":"topology/","page":"Topologies","title":"Topologies","text":"As it can be pretty clunky to create every neighborhood-list manually, Mango.jl provides several functions to make your life easier. For this it relys on Graphs.jl and MetaGraphsNext.jl as datastructure and for graph-construction","category":"page"},{"location":"topology/#Creating-topologies","page":"Topologies","title":"Creating topologies","text":"","category":"section"},{"location":"topology/","page":"Topologies","title":"Topologies","text":"First, there are several pre-defined topologies. It is also possible to use an arbitrary Graphs.jl graph. After the creation of the topology, the agents need to be added to the topology. This can be done with per_node(topology) do node ... end. In the do-block it is possible to add agents to nodes, the do-block will be executed per vertex of your graph. ","category":"page"},{"location":"topology/","page":"Topologies","title":"Topologies","text":"topology = complete_topology() # fully connected \ntopology = star_topology() # star\ntopology = cycle_topology() # cycle\ntopology = graph_topology(your_graph) # based on arbitrary Graphs.jl AbstractGraph\nper_node(topology) do node\n    add!(node, MyAgent())\nend","category":"page"},{"location":"topology/","page":"Topologies","title":"Topologies","text":"However, often this approach is not feasible, because you create a specific agent system with agents which need to be linked in a very specific way, such that it is not possible to assign the same agent type to every node. For this reason you can define the topology manually:","category":"page"},{"location":"topology/","page":"Topologies","title":"Topologies","text":"topology = create_topology() do topology\n    agent = register(container, TopologyAgent())\n    agent2 = register(container, TopologyAgent())\n    agent3 = register(container, TopologyAgent())\n    n1 = add_node!(topology, agent)\n    n2 = add_node!(topology, agent2)\n    n3 = add_node!(topology, agent3)\n    add_edge!(topology, n1, n2)\n    add_edge!(topology, n1, n3)\nend","category":"page"},{"location":"topology/#Using-the-topology","page":"Topologies","title":"Using the topology","text":"","category":"section"},{"location":"topology/","page":"Topologies","title":"Topologies","text":"At this point we know how to create topologies and how to populate them. To actually use them, the function topology_neighbors(agent_or_role) exists. The function returns a vector of AgentAddress objects, which represent all other agents in the neighborhood of agent.","category":"page"},{"location":"container/#Real-Time-Container","page":"Container","title":"Real Time Container","text":"","category":"section"},{"location":"container/","page":"Container","title":"Container","text":"The real time container feature in Mango.jl allows you to create and manage a container, which acts as the communication layer within the environment. A container is responsible for handling messages, forwarding them to the appropriate agents, and managing agent registration. The real time component means that the container acts on a real time clock, and does not differentiate between a simulation time and the execution time, which essentially means everything executed withing the real time container is executed immediately as stated in the code. In contrast, there is also a \"simulation\" container, which maintains an interal simulation time and only executes tasks and delivers messages according to the requested step_sizes (next event time). More on the simulation container can be found under Simulation Container. Note, that both container types implement the methods for the ContainerInterface and can therefore be drop-in replacements for the each other with slight differences in usage.","category":"page"},{"location":"container/#Container-Struct","page":"Container","title":"Container Struct","text":"","category":"section"},{"location":"container/","page":"Container","title":"Container","text":"The Container struct represents the container as an actor within the environment. It is implemented using composition, making it flexible to use different protocols and codecs for message communication. The key components of the Container struct are:","category":"page"},{"location":"container/","page":"Container","title":"Container","text":"protocol: The protocol used for message communication (e.g., TCP).\ncodec: A pair of functions for encoding and decoding messages in the container.","category":"page"},{"location":"container/#Start-and-Shutdown","page":"Container","title":"Start and Shutdown","text":"","category":"section"},{"location":"container/","page":"Container","title":"Container","text":"Before using the container for message handling and agent management, you need to start the container using the start function. This function initializes the container's components and enables it to act as the communication layer.","category":"page"},{"location":"container/","page":"Container","title":"Container","text":"using Mango\n\n# Create a container instance\ncontainer = Container()\n\n# ... setup the container, agents, define handles, ...\n\n# Start the container\nwait(Threads.@spwan start(container))\n\n# Execute some functionality to e.g. trigger the agent system\n\n# Shut down the container\nshutdown(container)","category":"page"},{"location":"container/","page":"Container","title":"Container","text":"However, this approach can be error-prone for multiple reasons. Besides simply forgetting to call shutdown, an exception may occur between the start and shutdown calls on the containers, leading to resource leaks. For this reason, we recommend using activate(runnable, containers). With this function, the above `start/shutdown' pair translates to...","category":"page"},{"location":"container/","page":"Container","title":"Container","text":"# Start the container and shut it down after the runnable (do ... end) has been executed.\nactivate(container) do\n\n# Execute some functionality to e.g. trigger the agent system\n\nend","category":"page"},{"location":"container/#Registering-Agents","page":"Container","title":"Registering Agents","text":"","category":"section"},{"location":"container/","page":"Container","title":"Container","text":"To enable the container to manage agents and handle their messaging activities, you can register agents using the register function. This function associates an agent with a unique agent ID (AID) and adds the agent to the container's internal list.","category":"page"},{"location":"container/","page":"Container","title":"Container","text":"using Mango\n\n# Create a container instance\ncontainer = Container()\n\n# Define and create an agent\n@agent struct MyAgent\n    # Your agent's fields and methods here\nend\n\nmy_agent = MyAgent()\n\n# Register the agent with the container\nregister(container, my_agent)","category":"page"},{"location":"container/#Sending-Messages","page":"Container","title":"Sending Messages","text":"","category":"section"},{"location":"container/","page":"Container","title":"Container","text":"To send messages between agents within the container, you can use the send_message function. The container routes the message to the specified receiver agent based on the receiver's AID.","category":"page"},{"location":"container/","page":"Container","title":"Container","text":"using Mango\n\n# Create a container instance\ncontainer = Container()\n\n# ... Register agents ...\n\n# Sending a message from one agent to another\nsend_message(container, \"Hello from Agent 1!\", \"agent2_id\")","category":"page"},{"location":"container/#TCP","page":"Container","title":"TCP","text":"","category":"section"},{"location":"container/","page":"Container","title":"Container","text":"This protocol allows communication over plain TCP connections, enabling message exchange between different entities within the Mango.jl simulation environment.","category":"page"},{"location":"container/#Introduction","page":"Container","title":"Introduction","text":"","category":"section"},{"location":"container/","page":"Container","title":"Container","text":"The TCP Protocol in Mango.jl is a communication protocol used to exchange messages over plain TCP connections. It enables agents within the simulation environment to communicate with each other by establishing and managing TCP connections.","category":"page"},{"location":"container/#TCPProtocol-Struct","page":"Container","title":"TCPProtocol Struct","text":"","category":"section"},{"location":"container/","page":"Container","title":"Container","text":"The TCPProtocol struct represents the TCP Protocol within Mango.jl. It encapsulates the necessary functionalities for communication via TCP connections. Key features of the TCPProtocol struct are:","category":"page"},{"location":"container/","page":"Container","title":"Container","text":"address: The InetAddr represents the address on which the TCP server listens.\nserver: A TCPServer instance used for accepting incoming connections.","category":"page"},{"location":"container/#Usage","page":"Container","title":"Usage","text":"","category":"section"},{"location":"container/","page":"Container","title":"Container","text":"To use the tcp protocol you need to construct a TCPProtocol struct and assign it to the protocol field in the container.","category":"page"},{"location":"container/","page":"Container","title":"Container","text":"container2 = Container()\ncontainer2.protocol = TCPProtocol(address=InetAddr(ip\"127.0.0.2\", 2940))","category":"page"},{"location":"container/","page":"Container","title":"Container","text":"It is also possible to use the convenience function create_tcp_container.","category":"page"},{"location":"container/#MQTT","page":"Container","title":"MQTT","text":"","category":"section"},{"location":"container/#Introduction-2","page":"Container","title":"Introduction","text":"","category":"section"},{"location":"container/","page":"Container","title":"Container","text":"The MQTT protocol enables sending via an MQTT message broker. It allows a container to subscribe to different topics on a broker and publish messages to them.","category":"page"},{"location":"container/","page":"Container","title":"Container","text":"Currently, one container may only connect to a single broker. Subscribed topics for each agent are set on agent registration and tracked by the container. Incoming messages on these topics are distributed to the subscribing agents by the container.","category":"page"},{"location":"container/#MQTTProtocol-Struct","page":"Container","title":"MQTTProtocol Struct","text":"","category":"section"},{"location":"container/","page":"Container","title":"Container","text":"The MQTTProtocol contains the status and channels of the underlying mosquitto C library (as abstracted to Julia by the Mosquitto.jl package).","category":"page"},{"location":"container/","page":"Container","title":"Container","text":"The constructor takes a client_id and the broker_addr. Internally it also tracks the msg_channel and conn_channel, internal flags, the information to map topics to subscribing agents.","category":"page"},{"location":"container/","page":"Container","title":"Container","text":"protocol = MQTTProtocol(cliant_id, broker_addr)","category":"page"},{"location":"container/","page":"Container","title":"Container","text":"client_id - String id the container will communicate to the MQTT broker.\nbroker_addr - InetAddr of the MQTT broker","category":"page"},{"location":"container/#Usage-2","page":"Container","title":"Usage","text":"","category":"section"},{"location":"container/","page":"Container","title":"Container","text":"To use the mqtt protocol you need to construct a MQTTProtocol struct and assign it to the protocol field in the container. Further it is possible to use a convenience function for this  It is also possible to use the convenience function create_mqtt_container.","category":"page"},{"location":"container/","page":"Container","title":"Container","text":"container2 = Container()\ncontainer2.protocol = MQTTProtocol(\"my_id\", InetAddr(ip\"127.0.0.2\", 2940))","category":"page"},{"location":"container/","page":"Container","title":"Container","text":"Subscribing an agent to a topic can happen only as registration time and is not allowed otherwise. When registering a new agent to the container the topics to subscribe are passed by the topics keyword argument, taking a collection of String topic names. NOTE: It is recommended you pass a Vector{String} as this is what is tested.  Other collections could work but no guarantees are given.","category":"page"},{"location":"container/","page":"Container","title":"Container","text":"a1 = MyAgent(0)\nregister(c1, a1; topics=[\"topic1\", \"topic2\"])","category":"page"},{"location":"getting_started/#Getting-Started-with-Mango.jl","page":"Getting Started","title":"Getting Started with Mango.jl","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"In this getting started guide, we will explore the essential features of Mango.jl by creating a simple simulation of two ping pong agents that exchange messages in a container. We will set up a container with the TCP protocol, define ping pong agents, and enable them to exchange messages. You can also find working examples of the following code in examples.jl.","category":"page"},{"location":"getting_started/#.-Creating-a-Container-with-a-TCP-Protocol","page":"Getting Started","title":"1. Creating a Container with a TCP Protocol","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"To get started, we need to create a container to manage ping pong agents and facilitate communication using the TCP protocol:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"using Mango\n\n# Create the container instances with TCP protocol\ncontainer = create_tcp_container(\"127.0.0.1\", 5555)\ncontainer2 = create_tcp_container(\"127.0.0.1\", 5556)","category":"page"},{"location":"getting_started/#.-Defining-Ping-Pong-Agents","page":"Getting Started","title":"2. Defining Ping Pong Agents","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Let's define agent structs to represent the ping pong agents. Every new agent struct should be defined using the @agent macro to ensure compatibility with the mango container:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"using Mango\n\n# Define the ping pong agent\n@agent struct TCPPingPongAgent\n    counter::Int\nend","category":"page"},{"location":"getting_started/#.-Sending-and-Handling-Messages","page":"Getting Started","title":"3. Sending and Handling Messages","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Ping pong agents can exchange messages and they can keep track of the number of messages received. Let's implement message handling for the agents. To achieve this a new method handle_message from Mango has to be added:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"import Mango.handle_message\n\n# Override the default handle_message function for ping pong agents\nfunction handle_message(agent::TCPPingPongAgent, message::Any, meta::Any)\n    if message == \"Ping\"\n        agent.counter += 1\n        reply_to(agent, \"Pong\", meta)\n    elseif message == \"Pong\"\n        agent.counter += 1\n        reply_to(agent, \"Ping\", meta)\n    end\nend","category":"page"},{"location":"getting_started/#.-Sending-Messages","page":"Getting Started","title":"4. Sending Messages","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Now let's simulate the ping pong exchange by sending messages between the ping pong agents.  Addresses are provided to the send_message function via the AgentAddress struct. The struct consists of an aid and the more technical address field. Further an AgentAddress  can contain a tracking_id, which can identify the dialog agents are having.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"The send_message method here will automatically insert the agent as sender:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"# Define the ping pong agent\n# Create instances of ping pong agents\nping_agent = register(container, TCPPingPongAgent(0))\npong_agent = register(container2, TCPPingPongAgent(0))\n\nactivate([container, container2]) do\n    # Send the first message to start the exchange\n    send_message(ping_agent, \"Ping\", address(pong_agent))\n\n    # Wait for a moment to see the result\n    # In general you want to use a Condition() instead to\n    # Define a clear stopping signal for the agents\n    wait(Threads.@spawn begin\n        while ping_agent.counter < 5 \n            sleep(1)\n        end\n    end)\nend","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"In this example, the ping pong agents take turns sending \"Ping\" and \"Pong\" messages to each other, incrementing their counters. After a short moment, we can see the result of the ping pong process.","category":"page"},{"location":"getting_started/#.-Using-the-MQTT-Protocol","page":"Getting Started","title":"5. Using the MQTT Protocol","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"To use an MQTT messsage broker instead of a direkt TCP connection, you can use the MQTT protocol.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"broker_addr = InetAddr(ip\"127.0.0.1\", 1883)\n\nc1 = create_mqtt_container(\"127.0.0.1\", 1883, \"PingContainer\")\nc2 = create_mqtt_container(\"127.0.0.1\", 1883, \"PongContainer\")","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"The topics each agent subscribes to on the broker are provided during registration to the container. All messages on these topics will then be forwarded as messages to the agent.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"# Define the ping pong agent\n@agent struct MQTTPingPongAgent\n    counter::Int\nend\n\n# Define the ping pong agent\n# Create instances of ping pong agents\n# register each agent to a container\n# For the MQTT protocol, topics for each agent have to be passed here.\nping_agent = register(c1, MQTTPingPongAgent(0); topics=[\"pongs\"])\npong_agent = register(c2, MQTTPingPongAgent(0); topics=[\"pings\"])","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Just like the TCPProtocol, the MQTTProtocol has an associated struct for providing address information:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"the broker address\nthe topic","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Thus, sending of the first message becomes:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"# Send the first message to start the exchange\nwait(send_message(ping_agent, \"Ping\", MQTTAddress(broker_addr, \"pings\")))","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Lastly, handle_message has to be altered to send the corresponding answers correctly:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"# Override the default handle_message function for ping pong agents\nfunction handle_message(agent::MQTTPingPongAgent, message::Any, meta::Any)\n    broker_addr = agent.context.container.protocol.broker_addr\n\n    if message == \"Ping\"\n        agent.counter += 1\n        send_message(agent, \"Pong\", MQTTAddress(broker_addr, \"pongs\"))\n    elseif message == \"Pong\"\n        agent.counter += 1\n        send_message(agent, \"Ping\", MQTTAddress(broker_addr, \"pings\"))\n    end\nend","category":"page"},{"location":"#Mango.jl","page":"Home","title":"Mango.jl","text":"","category":"section"},{"location":"#Welcome-to-mango's-documentation!","page":"Home","title":"Welcome to mango's documentation!","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Mango.jl allows the user to create simple agents with little effort and at the same time offers options to structure agents with complex behaviour. The main features of mango are listed below.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Mango.jl as a package is partly based on the ideas of mango-agents, but will also contain new concepts and techniques. It was made with the picture of scalable agent simulations in mind.","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Container mechanism to speedup local message exchange\nStructuring complex agents with loose coupling and agent roles\nBuilt-in codecs\nSupports communication between agents directly via TCP and MQTT\nBuilt-in tasks mechanisms for proactive agent actions\nContinous and discrete stepping simulation using an external clock to rapidly run and inspect simulations designed for longer time-spans\nIntegrated communication and task simulation modules\nIntegrated environment with which the agents can interact in a common space","category":"page"},{"location":"#Development-state","page":"Home","title":"Development state","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Mango.jl is in an early development state. Feel free to try out the framework if you are interested and be aware that there might be some unexpected edges here and there.","category":"page"},{"location":"#License","page":"Home","title":"License","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Mango.jl is developed and published under the MIT license.","category":"page"},{"location":"role/#Roles","page":"Roles","title":"Roles","text":"","category":"section"},{"location":"role/","page":"Roles","title":"Roles","text":"Roles are used to provide a mechanism for reusability and modularization of functionsalities provided/implemented by agents. Every agent can contain and unlimited number of roles, which are separate structs on which typical agent functionalitites (like send_message) can be defined. All roles of an agent share the same address and agent id, as they are part of the agent and no autonomous unit for themself. ","category":"page"},{"location":"role/#Role-definition","page":"Roles","title":"Role definition","text":"","category":"section"},{"location":"role/","page":"Roles","title":"Roles","text":"A role can be defined using the @role macro. This macro adds some baselinefields to the following struct definition. The struct can be defined like any other Julia struct.","category":"page"},{"location":"role/","page":"Roles","title":"Roles","text":"# Define your role struct using @role macro\n@role struct MyRole\n    my_own_field::String\nend\n\n# Assume you have already defined roles using Mango.AgentRole module\nrole1 = MyRole(\"Role1\")","category":"page"},{"location":"role/","page":"Roles","title":"Roles","text":"Most functions, used for agent development can also be used with roles (e.g. handle_message, address, schedule, send_message (plus variants) and the lifecycle methods).  ","category":"page"},{"location":"role/","page":"Roles","title":"Roles","text":"Additionally, roles can define the setup function to define actions to take when the roles are added to the agent. It is also possible to subscribe to specific messages using a boolean expression with the subscribe_message(role::Role, handler::Function, condition::Function) function. With the @role macro, the role context is added to the role, which contains the reference to the agent. However, it is recommended to use the equivalent methods defined on the role to execute actions like scheduling and sending messages. Further with roles it is possible to listen to all messages sent from within the agent. For this subscribe_send(role, handler::Function) can be used.","category":"page"},{"location":"role/#Role-communication","page":"Roles","title":"Role communication","text":"","category":"section"},{"location":"role/","page":"Roles","title":"Roles","text":"Besides the message subscriptions there are functionalities to communicate/work together with other roles. There are two different mechanisms for this:","category":"page"},{"location":"role/","page":"Roles","title":"Roles","text":"Data sharing\nAn event system","category":"page"},{"location":"role/#Data-sharing","page":"Roles","title":"Data sharing","text":"","category":"section"},{"location":"role/","page":"Roles","title":"Roles","text":"The data sharing can be used using ordinary Julia structs with default constructors. There are two ways to share the data, first you can create the model you want share with get_model(role, your_data_model_type)","category":"page"},{"location":"role/","page":"Roles","title":"Roles","text":"struct TestModel\n    c::Int64\nend\nTestModel() = TestModel(42)\nrole = MyRole(\"Role1\")\nshared_model = get_model(role, TestModel)","category":"page"},{"location":"role/","page":"Roles","title":"Roles","text":"Mango.jl will create a TestModel instance and manage this instance such that every role can access it. ","category":"page"},{"location":"role/","page":"Roles","title":"Roles","text":"Although this is a straightforward method it can be very clumsy to use. For this reason there is the macro @shared, which can be used within a role definition to mark a field as shared model. Then, Mango.jl will ensure that a shared instance of the declared type will be created and assigned to the struct field.","category":"page"},{"location":"role/","page":"Roles","title":"Roles","text":"@role struct SharedFieldTestRole\n    @shared \n    test_model::TestModel\nend","category":"page"},{"location":"role/#Event-system","page":"Roles","title":"Event system","text":"","category":"section"},{"location":"role/","page":"Roles","title":"Roles","text":"Roles can emit events using emit_event(role, event::Any, event_type::Any=nothing). If event_type is nothing, the type of event will be used as event_type. To handle these events roles can subscribe using subscribe_event(role, event_type::Any, event_handler::Function, condition::Function) or add a method to handle_event. The condition function shall have the signature (source_role::Role, event::Any)::Boolean. The event handler shall have the signature (role::Role, source::Role, event::Any, event_type::Any).","category":"page"},{"location":"role/","page":"Roles","title":"Roles","text":"\nstruct TestEvent\nend\n\nfunction handle_event(role::Role, src::Role, event::TestEvent; event_type::Any)\n    @info \"Event is arriving!\"\nend\nfunction custom_handler(role::Role, src::Role, event::Any, event_type::Any)\n    @info \"Event is also arriving!\"\nend\n\n@agent struct RoleTestAgent\n    counter::Integer\nend\n\nagent = RoleTestAgent(0)\n\nrole_emitter = MyRole(\"Role1\")\nrole_handler = MyRole(\"Role1\")\n\nadd(agent, role_emitter)\nadd(agent, role_handler)    \nsubscribe_event(role1, TestEvent, custom_handler, (src, event) -> true) # condition is optional\n\nemit_event(role_emitter, TestEvent())","category":"page"}]
}
